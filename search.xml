<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hibernate (二)]]></title>
    <url>%2Fhibernate02%2F</url>
    <content type="text"><![CDATA[Hibernate 持久化类的编写规则什么是持久化类持久化：就是将内存中的数据永久的存储在关系型数据库中。 持久化类：指的是一个 Java 类与数据库表建立了映射关系，那么这么类就称之为持久化类。 持久化类的编写规则 首先编写持久化类需要提供无参的构造方法，在 Java 中默认构造即无参构造。 持久化类的属性需要私有，对私有的属性提供公共的 set 和 get 方法。 持久化类的属性要尽量使用包装类的类型。举个例子，假如使用基本数据类型 int，它默认值是 0，那么如果把这个 0 存到数据库中，就会产生歧义，到底是用户存的 0 呢，还是用户没有设置呢，它的默认值就是 0 呀。如果使用包装类 Integer 的话就可以避免发生这种情况，我们一起来分析一下，它的默认值是 null，如果用户存一个数，数据库中就会显示相应的数值，如果用户没有设置值，那么数据库中就会显示为 null，一目了然，歧义就解决了。 持久化类要有一个唯一标识 OID 与表的主键对应。 持久化类尽量不要使用 final 进行修饰。因为 Hibernate 中有延时加载优化机制，这个机制中会产生代理对象，会继承持久化类产生子类，从而产生代理对象，如果用 final 修饰的话，这个优化机制就失效了。 Hibernate 主键生成策略主键类型自然主键：把具有业务含义的字段作为主键，称为自然主键。 代理主键：把不具备业务含义的字段作为主键，称之为代理主键，通常使用 id 来作为主键。 Hibernate 的主键生成策略 在实际开发中一般是不允许用户手动设置主键的，一般是手动编写程序进行设置，再交给数据库，在 Hibernate 中为了减少程序代码的编写，它提供了很多中的主键生成策略。 increment：hibernate 中提供的自增长机制，适用 short、int、long 类型的主键。线程不安全，建议在单线程中使用。 identity：适用 short、int、long 类型的主键，采用的是数据库底层的自动增长机制。适用于有自动增长机制的数据库，如 MySQL 等。Oracle 是没有自动增长的。 sequence：适用 short、int、long 类型的主键，采用的是序列化的方式，支持 Oracle 等。 uuid：适用于字符串类型的主键。使用 hibernate 中的随机方式生成字符串主键，类似于 Java 给提供的 UUID 对象。 native：根据本地机制进行自动调整，可以在 identity 和 sequence 之间进行自动切换。 assigned：hibernate 放弃对主键的管理，需要手动编写程序或用户自己设置。 foreign：外部主键。 Hibernate 的持久化的三种状态Hibernate 为了更好的管理持久化类，将持久化类分成了三种状态。分别是瞬时态、持久态、脱管态或游离态。 瞬时态此状态对象没有唯一标识 OID，没有被 session 管理，称为是瞬时态对象。 持久态此状态对象有唯一标识 OID，且被 session 管理，称为持久态对象。 脱管态此状态对象有唯一标识 OID，但没有被 session 管理，称为脱管态对象。 如何区分三种状态对象通过一段代码解释 123456789101112@Testpublic void demo1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); // 瞬时态对象，没有唯一标识 OID，没有被 session 管理 customer.setCust_name("李四"); Serializable id = session.save(customer); // 持久态对象，有唯一标识 OID，被 session 管理 transaction.commit(); session.close(); // 脱管态对象，有唯一标识 OID，没有被 session 管理&#125; 三种状态对象的转换 瞬时态对象获得：Customer customer = new Customer()，简单来说就是 new 状态转换： 瞬时态 –&gt; 持久态 调用保存方法save(Object obj)、调用保存或更新方法saveOrUpdate(Object obj) 瞬时态 –&gt; 脱管态 设置 id，customer.setCust_id() 持久态对象获得：可通过查询方法get()、load()获得 状态转换： 持久态 –&gt; 瞬时态 调用删除方法delete() 持久态 –&gt; 脱管态 session 关闭close()、清除所有clear()、清除某一个对象evict(Object obj) 脱管态对象获得：两部曲，先 new 对象，然后设置 id。Customer customer = new Customer(); customer.setCust_id(1l); 状态转换： 脱管态 –&gt; 瞬时态 将该对象的 id 置为 null 即可 脱管态 –&gt; 持久态 update()、saveOrUpdate() 持久态对象的特性持久态对象能够自动更新数据库 123456789101112@Testpublic void demo2() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 获得持久化对象，持久化对象可以自动更新数据库 Customer customer = session.get(Customer.class, 1l); customer.setCust_name("哈哈"); // session.update(customer); transaction.commit(); session.close();&#125; 持久态对象之所以有自动更新数据库的特性是依赖于 Hibernate 的一级缓存。 Hibernate 的一级缓存什么是缓存缓存：是一种优化方式，将数据存到内存当中，使用时从缓存中获取，减少直接向永久性数据源的读取次数，提高应用的性能。 Hibernate 的一级缓存 Hibernate 中提供的优化手段：缓存、抓取策略。Hibernate 中提供了两种缓存机制：一级缓存、二级缓存。 Hibernate 的一级缓存，也称为是 Session 级别的缓存，一级缓存的生命周期与 Session 对象一致，其实一级缓存就是由 Session 对象中的一系列 Java 集合构成的。一级缓存是自带的且不可卸载的。 Hibernate 的二级缓存是基于 SessionFactory 级别的缓存，是需要配置的，通常二级缓存使用 Redis 替代较多。 证明一级缓存的存在123456789101112131415161718192021222324@Test// 证明一级缓存的存在public void demo1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); /*Customer customer1 = session.get(Customer.class, 1l); // 发送 SQL，从数据库中查询之后放到一级缓存中 System.out.println(customer1); Customer customer2 = session.get(Customer.class, 1l); // 不发送 SQL，直接从一级缓存中取 System.out.println(customer2); System.out.println(customer1 == customer2);*/ Customer customer1 = new Customer(); customer1.setCust_name("张三"); Serializable id = session.save(customer1); System.out.println(id); Customer customer2 = session.get(Customer.class, id); // 不发送 SQL，save() 之后，会将保存的对象放到缓存中 System.out.println(customer2); System.out.println(customer1 == customer2); transaction.commit(); session.close();&#125; Hibernate 的一级缓存结构 一级缓存内部存在一个特殊的区域：快照区 123456789101112@Test// 测试一级缓存的快照区public void demo2() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer1 = session.get(Customer.class, 1l); // 发送 SQL 语句，同时放到一级缓存和快照区 customer1.setCust_name("李四"); tx.commit(); session.close();&#125; Hibernate 的事务管理什么是事务事务指的是逻辑上的一组操作，组成这组操作的各个逻辑单元要么全部成功，要么全部失败。 事务的特性 原子性：代表事务不可分割。 一致性：代表事务执行前后，数据完整性保持一致。 隔离性：代表一个事务在执行过程中，不应该受到其他事务的干扰。 持久性：代表事务执行结束后，数据会持久保存到数据库中。 如果不考虑隔离性，引发的安全性问题读问题 脏读： 一个事务读到另一个事务未提交的数据。 不可重复读：一个事务读到另一个事务已提交的 update 更新数据，导致在前一个事务中多次查询结果不一致。 虚读：一个事务读到另一个事务已提交的 insert 添加数据，导致在前一个事务中多次查询结果不一致。 写问题 引发两类丢失更新 读写问题的解决通过设置事务的更新级别控制 Read uncommited：不能解决任何问题。 Read commited：可以解决脏读，但是不可重复读和虚读可能发生。（Oracle 的默认事务隔离级别） Repeatable read：可以解决脏读和不可重复读，但是虚读可能发生。（MySQL 的默认事务隔离级别） Serializable：可以解决所有的读问题，它属于死锁，安全性高，但效率低。 Hibernate 中设置事务隔离级别可以在 hibernate 的核心配置文件中设置 123&lt;!-- 设置事务隔离级别 --&gt;&lt;!-- 4 为 MySql 的默认级别 --&gt;&lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; 线程绑定 Session 将 Session 与当前线程绑定方便事务控制 改写使用 Hibernate 操作数据库的工具类123456789101112131415161718192021222324public class HibernateUtils &#123; // 创建 Configuration 对象 private final static Configuration cfg; // 创建 SessionFactory 对象 private final static SessionFactory sf; // 给两个变量赋值 static &#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; // 对外提供公共的方法获得连接对象 public static Session openSession() &#123; return sf.openSession(); &#125; // 将 Session 与当前线程绑定 public static Session getCurrentSession() &#123; return sf.getCurrentSession(); &#125; &#125; 在 Hibernate 核心配置文件中配置 要使用 getCurrentSession() 方法，需要在 hibernate 核心配置文件中配置后才能使用 12&lt;!-- 配置 session 绑定当前线程 --&gt;&lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; Hibernate 的其他 APIQueryQuery 代表面向对象的一个 Hibernate 查询操作，通常使用 session.createQuery() 方法接收一个 HQL（Hibernate Query Language）语句，然后进行查询操作。 12345678910111213141516171819202122232425262728293031@Test// Querypublic void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 // 通过 Session 获得 Query 接口，HQL：hibernate query language /* String hql = "from Customer"; Query query = session.createQuery(hql);*/ // 条件查询 /*String hql = "from Customer where cust_name like ?"; Query query = session.createQuery(hql); // 设置条件 query.setParameter(0, "张%"); // 在 hibernate 中 0 代表第一个问号*/ // 分页查询 String hql = "from Customer"; Query query = session.createQuery(hql); // 设置分页 query.setFirstResult(0); // 从第一条数据开始 query.setMaxResults(3); // 每页显示 3 条数据 List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; CriteriaCriteria 是一个完全面向对象，可扩展的条件查询 API，Criteria 查询又称为 QBC（Query By Criteria）查询。 1234567891011121314151617181920212223242526@Test// Criteriapublic void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过 Session 获得 Criteria 接口 Criteria criteria = session.createCriteria(Customer.class); // 简单查询/查询所有 // List&lt;Customer&gt; list = criteria.list(); // 条件查询 /*criteria.add(Restrictions.like("cust_name", "张", MatchMode.START)); // 匹配名字开头是张的数据 List&lt;Customer&gt; list = criteria.list();*/ // 分页查询 criteria.setFirstResult(3); criteria.setMaxResults(3); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; SQLQuerySQLQuery 这个接口用于接收一个 sql 语句进行查询。 123456789101112131415161718192021222324252627282930@Test// SQLQuerypublic void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 /*String sql = "select * from cst_customer"; SQLQuery query = session.createSQLQuery(sql);*/ // 条件查询 /*String sql = "select * from cst_customer where cust_name=?"; SQLQuery query = session.createSQLQuery(sql); // 设置条件 query.setParameter(0, "哈哈");*/ // 分页查询 String sql = "select * from cst_customer limit ?, ?"; SQLQuery query = session.createSQLQuery(sql); // 设置分页 query.setParameter(0, 3); query.setParameter(1, 3); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit();&#125; 注意将 Session 绑定在线程上后，当线程执行完毕之后，Session 对象也会自动关闭，不需要手动 session.close() 关闭，否则会报错。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate (一)]]></title>
    <url>%2Fhibernate01%2F</url>
    <content type="text"><![CDATA[Hibernate 框架概述 什么是框架 框架是软件的半成品，已经完成了部分功能，可以提交开发效率。 什么是 Hibernate 简单地说，Hibernate 就是持久层（dao 层） 的 ORM 框架。 什么是 ORM ORM：全称 Object Relational Mapping，意思即对象关系映射，指的是将一个 Java 中的实体类与关系型数据库中的表建立一种映射关系，从而操作对象就可以操作数据库中的表。 Hibernate 的入门 下载 Hibernate 开发环境并解压到本地 下载地址 创建一个项目，引入相应的 jar 包 数据库驱动包 Hibernate 开发的必须 jar 包 Hibernate 的日志记录包 在数据库中创建表 建表 SQL 语句 12345678910CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; @Override public String toString() &#123; return "Customer [cust_id=" + cust_id + ", cust_name=" + cust_name + ", cust_source=" + cust_source + ", cust_industry=" + cust_industry + ", cust_level=" + cust_level + ", cust_phone=" + cust_phone + ", cust_mobile=" + cust_mobile + "]"; &#125;&#125; 创建映射 映射通过 XML 的配置文件完成，配置文件可以任意命名，但通常使用统一命名规范（类名.hbm.xml）[hbm : hibernate mapping] 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;class name=&quot;com.test.hibernate.demo1.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;!-- 建立类中的属性与表中的主键对应 --&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot; &gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; length=&quot;32&quot; /&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot; length=&quot;32&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 创建一个 Hibernate 核心配置文件 Hibernate 核心配置文件的名称：hibernate.cfg.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 1. 连接数据库的基本参数 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;1&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 2. 可选配置 --&gt; &lt;!-- 打印SQL --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 格式化SQL --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 3. 导入映射文件 --&gt; &lt;mapping resource=&quot;com/test/hibernate/demo1/Customer.hbm.xml&quot; /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 编写测试代码 保存客户 java 代码 123456789101112131415161718192021222324252627282930313233343536373839/** * Hibernate 的入门案例 * @author Tong * */import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;public class HibernateDemo1 &#123; @Test // 保存客户的案例 public void demo1() &#123; // 1.加载 Hibernate 核心配置文件 Configuration configuration = new Configuration().configure(); // 手动加载映射 //configuration.addResource("com/test/hibernate/demo1/Customer.hbm.xml"); // 2.创建一个 SessionFactory 对象，类似于 JDBC 的连接池 SessionFactory SessionFactory = configuration.buildSessionFactory(); // 3.通过 SessionFactory 对象获得一个 Session 对象，相当于 JDBC 中的 Connection Session session = SessionFactory.openSession(); // 4.手动开启事务 Transaction transaction = session.beginTransaction(); // 5.编写代码 Customer customer = new Customer(); customer.setCust_name("赵六"); session.save(customer); // 6.提交事务 transaction.commit(); // 7.释放资源 session.close(); &#125; &#125; 数据库表 Hibernate 的常见配置XML 提示配置 Hibernate 映射文件的配置 class 标签的配置 class 标签用来建立类与表的映射关系 常用属性： ​ name：类的全路径 ​ table：表名（类名与表名一致时，table 可以省略） id 标签的配置 id 标签用来建立类中属性与表中主键的对应关系 常用属性： ​ name：类中的属性名 ​ column：表中的字段名（类中的属性名与表中的字段名一致时，column 属性可以省略） ​ length：长度 ​ type：类型 property 标签的配置 property 标签用来建立类中的普通属性与表中字段的对应关系 常用属性： ​ name：类中的属性名 ​ column：表中的字段名 ​ length：长度 ​ type：类型 ​ not-null：设置非空 ​ unique：设置唯一 Hibernate 的核心配置 可以分为三部分 必须的配置 连接数据库的基本参数 驱动类、url 路径、用户名、密码 方言 可选的配置 显示 SQL：hibernate.show_sql 格式化 SQL：hibernate.format_sql 自动建表：hibernate.hbm2ddl.auto 取值 none：不使用 hibernate 的自动建表 ceate：如果数据库中有表，删除原有表，重新创建，如果没有表，则新建表 create-drop：如果数据库中有表，删除原有表新建表，执行操作后再删除表。如果没有表，则新建表，使用完后再删除该表 update：如果数据库中有表，使用原有表（update 会该表表结构），如果没有表，则创建新表 validate：如果数据库中没有表，不会创建表，如果有表，则会校验映射和表结构 映射文件的引入 引入映射文件的位置 1&lt;mapping resource=&quot;com/test/hibernate/demo1/Customer.hbm.xml&quot; /&gt; Hibernate 的核心 APIConfiguration Hibernate 的配置对象 作用 加载核心配置文件 1Configuration configuration = new Configuration().configure(); 可手动加载映射文件 1configuration.addResource("com/test/hibernate/demo1/Customer.hbm.xml"); SessionFactory Session 工厂，SessionFactory 内部维护了 Hibernate 的连接池和 Hibernate 的二级缓存，是线程安全的对象，其次一个项目创建一个对象即可。 配置连接池 1234567891011&lt;!-- 配置C3P0连接池 --&gt;&lt;property name=&quot;connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt;&lt;!--在连接池中可用的数据库连接的最少数目 --&gt;&lt;property name=&quot;c3p0.min_size&quot;&gt;5&lt;/property&gt;&lt;!--在连接池中所有数据库连接的最大数目 --&gt;&lt;property name=&quot;c3p0.max_size&quot;&gt;20&lt;/property&gt;&lt;!--设定数据库连接的过期时间,以秒为单位,如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt;&lt;property name=&quot;c3p0.timeout&quot;&gt;120&lt;/property&gt;&lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt;&lt;property name=&quot;c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; 抽取 Hibernate 工具类，方便使用 123456789101112131415161718192021222324/** * Hibernate 的工具类 * @author Tong * */public class HibernateUtils &#123; // 创建 Configuration 对象 private final static Configuration cfg; // 创建 SessionFactory 对象 private final static SessionFactory sf; // 给两个变量赋值 static &#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; // 对外提供公共的方法获得连接对象 public static Session openSession() &#123; return sf.openSession(); &#125; &#125; Session Session 代表的是 Hibernate 与数据库的连接对象，是与数据库交互的桥梁，不同于 HttpSession，它是线程不安全的，所以一般在局部使用。 Session 中的 API 保存方法 session.save(Object)返回值是一个Serializable id 12345678910111213141516@Test// 保存客户public void demo1() &#123; // 获得 Session 连接对象 Session session = HibernateUtils.openSession(); // 手动开启事务 Transaction transaction = session.beginTransaction(); // 编写代码 Customer customer = new Customer(); customer.setCust_name("张三"); session.save(customer); // 提交事务 transaction.commit(); // 释放资源 session.close();&#125; 查询方法 T get(Class c, Serializable id) T load(Class c, Serialzable id) get 方法和 load 方法的区别？ get 方法 get 方法是立即加载，当执行到 get() 方法这行代码时，会立即发送 SQL 语句去查询 查询之后是真实对象本身 当查询一个不存在的对象时，返回的结果是 null load 方法 load 方法是延时加载（懒加载），当执行到 load() 方法这行代码时，不会发送 SQL 语句去查询，直到调用该对象时才会发送 SQL 语句去查询 查询之后是通过第三方 javassist 技术处理的代理对象 当查询一个不存在的对象时，会抛出 ObjectNotFoundException 异常 1234567891011121314151617@Test// 查询客户public void demo2() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 使用 get 方法查询 Customer customer = session.get(Customer.class, 1L); System.out.println(customer); // 使用 load 方法查询 /*Customer customer = session.load(Customer.class, 2l); System.out.println(customer);*/ tx.commit(); session.close();&#125; 修改方法 void update(Object obj) 1234567891011121314151617181920@Test// 修改操作public void demo3() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 直接创建对象修改 /*Customer customer = new Customer(); customer.setCust_id(1l); customer.setCust_name("王五");; session.update(customer);*/ // 先查询，再修改(推荐) Customer customer = session.get(Customer.class, 1l); customer.setCust_name("赵六"); session.update(customer); tx.commit(); session.close();&#125; 删除方法 void delete(Object obj) 123456789101112131415161718@Test// 删除操作public void delete() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 创建对象直接删除 /*Customer customer = new Customer(); customer.setCust_id(2l); session.delete(customer);*/ // 先查询，再删除(推荐) -- 多表关系时可以实现级联删除 Customer customer = session.get(Customer.class, 3l); session.delete(customer); tx.commit(); session.close();&#125; 保存或更新 void saveOrUpdate(Object obj) 12345678910111213141516171819@Test// 保存或更新public void demo5() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 表中没有此数据，保存 /*Customer customer = new Customer(); customer.setCust_name("赵二"); session.saveOrUpdate(customer);*/ // 表中有此数据，更新 Customer customer = new Customer(); customer.setCust_id(2l); customer.setCust_name("天一"); session.saveOrUpdate(customer); tx.commit(); session.close();&#125; 查询所有 通过 HQL createQuery 和 SQL createSQLQuery 查询 1234567891011121314151617181920212223@Test// 查询所有public void demo6() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 接收 HQL，hibernate query language /*Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer.toString()); &#125;*/ // 接收 SQL SQLQuery query = session.createSQLQuery("select * from cst_customer"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; // 对象数组以字符串形式打印输出 System.out.println(Arrays.toString(objects)); &#125; tx.commit(); session.close();&#125; Transaction 事务对象 常用 API commit():提交事务 rollback():回滚事务 学习目标通过以上知识的学习能够独立搭建 Hibernate 的开发环境完成 CRUD 操作即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[This is my first blog.Hello, everyone! This is my first blog! java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Hibernate 的其他 API * @author Tong * */public class HibernateDemo5 &#123; @Test // Query public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 // 通过 Session 获得 Query 接口，HQL：hibernate query language /* String hql = "from Customer"; Query query = session.createQuery(hql);*/ // 条件查询 /*String hql = "from Customer where cust_name like ?"; Query query = session.createQuery(hql); // 设置条件 query.setParameter(0, "张%"); // 在 hibernate 中 0 代表第一个问号*/ // 分页查询 String hql = "from Customer"; Query query = session.createQuery(hql); // 设置分页 query.setFirstResult(0); // 从第一条数据开始 query.setMaxResults(3); // 每页显示 3 条数据 List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit(); &#125; @Test // Criteria public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过 Session 获得 Criteria 接口 Criteria criteria = session.createCriteria(Customer.class); // 简单查询/查询所有 // List&lt;Customer&gt; list = criteria.list(); // 条件查询 /*criteria.add(Restrictions.like("cust_name", "张", MatchMode.START)); // 匹配名字开头是张的数据 List&lt;Customer&gt; list = criteria.list();*/ // 分页查询 criteria.setFirstResult(3); criteria.setMaxResults(3); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit(); &#125; @Test // SQLQuery public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 /*String sql = "select * from cst_customer"; SQLQuery query = session.createSQLQuery(sql);*/ // 条件查询 /*String sql = "select * from cst_customer where cust_name=?"; SQLQuery query = session.createSQLQuery(sql); // 设置条件 query.setParameter(0, "哈哈");*/ // 分页查询 String sql = "select * from cst_customer limit ?, ?"; SQLQuery query = session.createSQLQuery(sql); // 设置分页 query.setParameter(0, 3); query.setParameter(1, 3); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit(); &#125; &#125;]]></content>
  </entry>
</search>
