<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring（三）]]></title>
    <url>%2Fspring_03%2F</url>
    <content type="text"><![CDATA[Spring 整合 JDBCJdbcTemplate 模板对象概述Spring 中提供了一个可以操作数据库的对象 JdbcTemplate 模板对象，内部封装了 jdbc 技术。 JdbcTemplate 的使用它的使用与 DBUtils 中的 QueryRunner 非常相似。 1234567891011121314151617181920@Testpublic void fun1() throws Exception &#123; // 0. 准备连接池 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass("com.mysql.jdbc.Dirver"); dataSource.setJdbcUrl("jdbc:mysql:///hibernate_day04"); dataSource.setUser("root"); dataSource.setPassword("1"); // 1. 创建 JDBC 模板对象 JdbcTemplate jt = new JdbcTemplate(); jt.setDataSource(dataSource); // 2. 书写 sql 并执行 String sql = "insert into user values(null, '张三')"; jt.update(sql);&#125; Spring 整合 JdbcTemplate 的使用导入 jar 包 4 个 spring 核心包 + 2 个日志包 spring-test 单元测试包 + spring-aop 包 spring-jdbc 包 + spring-tx 事务包 c3p0 连接池 + jdbc 驱动包 书写 Dao 的接口12345678910111213141516public interface UserDao &#123; // 增加用户 void save(User user); // 删除用户 void delete(Integer id); // 修改用户 void update(User user); // 查询一个用户 User getUserById(Integer id); // 查询总用户记录数 int getTotalCount(); // 查询所有用户 List&lt;User&gt; getAllUser(); &#125; 书写 Dao 的实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class UserDaoImpl /*extends JdbcDaoSupport*/ implements UserDao &#123; // 继承 JdbcDaoSupport 之后可以直接获得模板对象 private JdbcTemplate jt; public void setJt(JdbcTemplate jt) &#123; this.jt = jt; &#125; @Override public void save(User user) &#123; String sql = "insert into user values(null, ?)"; jt.update(sql, user.getName()); &#125; @Override public void delete(Integer id) &#123; String sql = "delete from user where id = ?"; jt.update(sql, id); &#125; @Override public void update(User user) &#123; String sql = "update user set name = ? where id = ?"; jt.update(sql, user.getName(), user.getId()); &#125; @Override public User getUserById(Integer id) &#123; String sql = "select * from user where id = ?"; User user = jt.queryForObject(sql, new RowMapper&lt;User&gt;() &#123; @Override public User mapRow(ResultSet rs, int arg1) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setName(rs.getString("name")); return user; &#125; &#125;, id); return user; &#125; @Override public int getTotalCount() &#123; String sql = "select count(*) from user"; Integer count = jt.queryForObject(sql, Integer.class); return count; &#125; @Override public List&lt;User&gt; getAllUser() &#123; String sql = "select * from user"; List&lt;User&gt; list = jt.query(sql, new RowMapper&lt;User&gt;() &#123; @Override public User mapRow(ResultSet rs, int arg1) throws SQLException &#123; User user = new User(); user.setId(rs.getInt("id")); user.setName(rs.getString("name")); return user; &#125; &#125;); return list; &#125;&#125; Spring 的配置将需要创建的对象交给 spring 容器来管理，并注入依赖关系。 123456789101112131415&lt;!-- 1. 将连接池交给 spring 容器管理 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///hibernate_day04"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="1"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2. 将 JdbcTemplate 交给 spring 容器管理 --&gt;&lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3. 将 UserDao 交给 Spring 容器管理 --&gt;&lt;bean name="userDao" class="com.test.a_jdbctemplate.UserDaoImpl"&gt; &lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 测试 Spring 和 JDBC 的整合 */// spring 帮我们创建一个容器@RunWith(SpringJUnit4ClassRunner.class)// 指定 spring 配置文件的路径@ContextConfiguration("classpath:applicationContext.xml")public class Demo &#123; // 注入 userDao 对象给 userDao 变量 @Resource(name="userDao") private UserDao userDao; @Test // 测试保存方法 public void fun2() &#123; User user = new User(); user.setName("tom"); userDao.save(user); &#125; @Test // 测试更新方法 public void fun3() &#123; User user = new User(); user.setId(2); user.setName("jack"); userDao.update(user); &#125; @Test // 测试删除方法 public void fun4() &#123; userDao.delete(2); &#125; @Test // 测试查询一个对象的方法 public void fun5() &#123; System.out.println(userDao.getUserById(1)); &#125; @Test // 测试查询所有记录条数的方法 public void fun6() &#123; System.out.println(userDao.getTotalCount()); &#125; @Test // 测试查询所有对象的方法 public void fun7() &#123; System.out.println(userDao.getAllUser()); &#125; &#125; 进阶知识点JdbcDaoSupport123public class UserDaoImpl /*extends JdbcDaoSupport*/ implements UserDao &#123; ...&#125; 实现类继承了 JdbcDaoSupport 类之后，就可以从该类中通过getJdbcTemplate()方法直接获得 JdbcTemplate 模板对象了。 Spring 读取外部的 Properties 配置文件书写连接数据库的配置文件1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.jdbcUrl=jdbc:mysql:///hibernate_day04jdbc.user=rootjdbc.password=1 Spring 读取 Properties 配置文件想让 spring 读取 Properties 配置文件，首先需要在 spring 配置文件中指定 Properties 配置文件的路径。然后使用 ${} 从配置文件中获取数据。 12345678910&lt;!-- 指定读取 db.properties 属性配置文件 --&gt;&lt;context:property-placeholder location="classpath:db.properties"/&gt;&lt;!-- 1. 将连接池交给 spring 容器管理 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driverClass&#125;"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.jdbcUrl&#125;"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.user&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; Spring 中的 aop 事务Spring AOP 事务概述Spring 中封装了事务管理的代码，但是因为在不同平台上操作事务的代码各不相同，因此 spring 提供了一个接口 PlatformTransactionManager，叫做平台事务管理器。针对不同的平台 spring 又提供了不同的实现类。例如： JDBC：DataSourceTransactionManager Hibernate：HibernateTransactionManager Spring 管理事务的属性事务管理级别属性 未提交读 : 脏读，不可重复读，虚读都有可能发生 。 已提交读 : 避免脏读。但是不可重复读和虚读有可能发生 。（Oracle 默认） 可重复读 : 避免脏读和不可重复读.但是虚读有可能发生。（Mysql 默认） 串行化 : 避免所有读问题。 是否只读属性两个取值。 true：只读，false：可以进行更新操作。 事务的传播行为属性事务的传播行为决定的是业务方法之间进行平行调用时，事务应该如何处理。 取值： PROPAGATION_REQUIRED 支持当前事务，如果不存在就新建一个(默认) PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务 PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常 PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务 PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务 PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常 PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行 Spring 管理事务的方式 通过一个转账的案例来演示配置 XML 配置导入 jar 包 导入新的命名空间（/约束）导入 aop 约束和 tx 事务约束 准备工作AccountDaoImpl 123456789101112131415public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123; @Override // 加钱方法 public void increaseMoney(Integer id, Double money) &#123; getJdbcTemplate().update("update account set money = money+? where id = ? ", money, id); &#125; @Override // 减钱方法 public void decreaseMoney(Integer id, Double money) &#123; getJdbcTemplate().update("update account set money = money-? where id = ? ", money, id); &#125;&#125; AccountServiceImpl 1234567891011121314151617181920public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override // 转账方法 public void transfer(Integer from, Integer to, Double money) &#123; // 减钱 accountDao.decreaseMoney(from, money); // int i = 1 / 0; // 加钱 accountDao.increaseMoney(to, money); &#125;&#125; 配置事务通知1234567891011&lt;!-- 配置事务通知 --&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- &lt;tx:method name="save*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="delete*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="update*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false"/&gt; &lt;tx:method name="find*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true"/&gt; --&gt; &lt;tx:method name="transfer" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 将通知织入到目标对象中1234567&lt;!-- 将事务通知织入到目标对象中 --&gt;&lt;aop:config&gt; &lt;!-- 配置切点 --&gt; &lt;aop:pointcut expression="execution(* com.test.service.*ServiceImpl.*(..))" id="txPc"/&gt; &lt;!-- 配置切面 ：切点引用 + 通知引用 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc"/&gt;&lt;/aop:config&gt; 测试123456789101112131415// spring 帮我们创建容器@RunWith(SpringJUnit4ClassRunner.class)// 指定加载 spring 配置文件的路径@ContextConfiguration("classpath:applicationContext.xml")public class Demo &#123; @Resource(name="accountService") private AccountService as; @Test public void fun1() &#123; as.transfer(1, 2, 100d); &#125; &#125; 注解配置前三步与 XML 配置相同 在 Spring 配置文件中开启注解管理事务12&lt;!--开启使用注解管理 aop 事务 --&gt;&lt;tx:annotation-driven/&gt; 在 Service 类上使用注解进行配置在方法上使用 123456789101112@Override// 转账方法@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)public void transfer(Integer from, Integer to, Double money) &#123; // 减钱 accountDao.decreaseMoney(from, money); // int i = 1 / 0; // 加钱 accountDao.increaseMoney(to, money);&#125; 在类上使用 1234@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)public class AccountServiceImpl implements AccountService &#123; ...&#125; 测试同上]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring（二）]]></title>
    <url>%2Fspring_02%2F</url>
    <content type="text"><![CDATA[使用注解配置 Spring配置步骤 导入 jar 包 4 个 spring 的核心包 + 2 个日至相关包 + spring-aop 包 为配置文件引入 context 命令空间（约束） 开启使用注解代理配置文件 12&lt;!-- 指定扫描 com.test.bean 包下（包含子包）的所有类中的注解 --&gt;&lt;context:component-scan base-package="com.test.bean"&gt;&lt;/context:component-scan&gt; 在类中使用注解完成相关配置 配置详情将对象注册到容器中将对象注册到 spring 容器中作为组件，Component、Service、Controller、Repository 注解在功能上一样的，只是为了更好的区分是哪一层的对象。 1234567@Component("user")// @Service("user") : service 层// @Controller("user") : web 层// @Repository("user") : dao 层public class User &#123; ...&#125; 指定对象的作用范围123456// 指定 scope 作用范围属性// @Scope(scopeName="prototype") // 多例@Scope(scopeName="singleton") // 单例，singleton 为默认值public class User &#123; ...&#125; 属性注入值类型注入有两种方式，一种是在属性上加@Value注解，另一种是在属性的 set 方法上加@Value注解。两种方式任选一种即可。 123456789// 方式一@Value("tom")private String name;// 方式二@Value("tom")public void setName(String name) &#123; this.name = name;&#125; 引用类型注入有三种方式，第三种方式更加简便常用。 123456789// 方式一：自动装配，spring 帮我们从指定包下扫描类型相同的对象进行自动匹配@Autowired // 方式二：如果存在多个类型一样的对象，则需要 @Autowired 配合使用 @Qualifier 注解指定具体的名称@Autowired @Qualifier("car2") // 方式三：手动注入，指定注入哪个名称的对象（最常用的方式）@Resource(name="car") 设置初始化和销毁方法相当于在 bean 标签上配置 init-method和destory-method属性。 1234567891011// 对象创建后，容器会调用对象的 init 方法@PostConstruct // 相当于属性 init-methodpublic void init() &#123; System.out.println("我是初始化方法！");&#125;// 容器关闭和对象销毁前，会调用对象的 destory 方法@PreDestroy // 相当于属性 destory-methodpublic void destory() &#123; System.out.println("我是销毁方法！");&#125; Spring 和 Junit 的整合导入 jar 包4 个 spring 核心包 + 2 个日志包 + spring-aop 包 + spring-test 包 相关配置与测试12345678910111213141516// Spring 帮我们创建容器@RunWith(SpringJUnit4ClassRunner.class)// 指定 spring 配置文件的路径@ContextConfiguration("classpath:applicationContext.xml")public class Demo &#123; // 将容器中名为 user 的对象注入到 user 变量中 @Resource(name="user") private User user; @Test public void fun1() &#123; System.out.println(user); &#125; &#125; Spring AOP 概述 AOP：Aspect Oriented Programming，面向切面编程。 Spring 中的 AOP 概念Spring 可以为容器中管理的对象生成代理对象，以前我们要使用代理，需要手动去编写代码来生成代理对象，那么现在可以通过 spring AOP 就能够帮我们生成代理对象。 Spring 实现 AOP 的原理Spring AOP 内部封装了两种代理技术，分别适用于不同的情况 动态代理1234567891011121314151617181920212223242526272829303132333435/** * 动态代理 * @author Tong * */public class UserServiceProxyFactory implements InvocationHandler &#123; private UserService us; public UserServiceProxyFactory(UserService us) &#123; super(); this.us = us; &#125; public UserService getUserServiceProxy() &#123; // 生成动态代理对象 UserService usProxy = (UserService) Proxy.newProxyInstance( UserServiceProxyFactory.class.getClassLoader(), UserServiceImpl.class.getInterfaces(), this ); // 返回代理对象 return usProxy; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开启事务"); Object invoke = method.invoke(us, args); System.out.println("提交事务"); return invoke; &#125; &#125; Cglib 代理12345678910111213141516171819202122232425262728/** * cglib 代理 * @author Tong * */public class UserServiceProxyFactory2 implements MethodInterceptor &#123; public UserService getUserServiceProxy() &#123; Enhancer en = new Enhancer(); // 帮我们创建代理对象的 en.setSuperclass(UserServiceImpl.class); // 设置对哪个类进行代理 en.setCallback(this); // 代理要做什么 UserService us = (UserService) en.create(); // 创建代理对象 return us; &#125; @Override public Object intercept(Object proxyObj, Method arg1, Object[] arg2, MethodProxy methodProxy) throws Throwable &#123; // 打开事务 System.out.println("打开事务"); // 调用原有方法 Object invokeSuper = methodProxy.invokeSuper(proxyObj, arg2); // 提交事务 System.out.println("提交事务"); return invokeSuper; &#125;&#125; 两种代理技术的比较动态代理：被代理对象要实现接口才能产生代理对象，如果没有接口将不能使用动态代理技术。 Cglib 代理：cglib 代理是第三方的代理技术，可以对任何类生成代理对象，它的原理是对目标对象进行继承代理，如果目标对象被 final 修饰，则此类将无法被 cglib 代理。 比较：如果被代理对象有接口，优先使用动态代理技术，否则使用 cglib 代理技术。 AOP 中的名词 JoinPoint：连接点，指的是目标对象中所有可以增强的方法。 Pointcut：切入点，指的是在目标对象中需要增强的方法。 Advice：通知/增强，指的就是增强的代码。 Target：目标对象，即被代理对象。 Weaving：织入，是一个过程，指的是将通知应用到切入点的这一过程。 Proxy：代理，指的是将通知织入到目标对象之后，形成的代理对象。 Aspect：切面，即切入点和通知的结合。 Spring 中的 AOP 的使用使用 XML 配置导入 jar 包4 个 spring 核心包 + 2 个日志包 + 2 个 spring 的 aop 包（spring-aspect、spring-aop）+ 2 个第三方 aop 包（com.springsource.org.aopalliance-1.0.0.jar、com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar） 准备目标对象1234567891011121314151617181920212223public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; System.out.println("保存用户"); &#125; @Override public void delete() &#123; System.out.println("删除用户"); &#125; @Override public void update() &#123; System.out.println("修改用户"); &#125; @Override public void find() &#123; System.out.println("查找用户"); &#125; &#125; 准备通知对象1234567891011121314151617181920212223242526272829303132333435363738394041/** * AOP 通知类 * 通知的分类 * 1. 前置通知：目标方法运行之前调用 * 2. 后置通知：目标方法运行之后调用（出现异常不会调用） * 3. 环绕通知：在目标方法执行之前和之后调用 * 4. 异常拦截通知：如果出现异常就会调用 * 5. 后置通知：目标方法运行之后调用（出现异常也会继续调用） * @author Tong * */public class MyAdvice &#123; // 前置通知 public void before() &#123; System.out.println("这是前置通知!"); &#125; // 后置通知（出现异常不会调用） public void afterReturning() &#123; System.out.println("这是后置通知（出现异常不会调用）"); &#125; // 环绕通知 public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("这是环绕通知之前的部分！"); Object proceed = pjp.proceed(); // 调用目标方法 System.out.println("这是环绕通知之后的部分！"); return proceed; &#125; // 异常通知 public void afterException() &#123; System.out.println("出事啦，出现异常了！"); &#125; // 后置通知（出现异常也会继续调用） public void after() &#123; System.out.println("这是后置通知（出现异常也会调用）!"); &#125;&#125; 将配置织入目标对象中123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt; &lt;!-- 准备工作：导入 aop（约束）命名空间 --&gt; &lt;!-- 1. 配置目标对象 --&gt; &lt;bean name="userService" class="com.test.service.UserServiceImpl"&gt;&lt;/bean&gt; &lt;!-- 2. 配置通知对象 --&gt; &lt;bean name="myAdvice" class="com.test.d_springaop.MyAdvice"&gt;&lt;/bean&gt; &lt;!-- 3. 将通知织入目标对象 --&gt; &lt;!-- aop 的配置 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点 切入表达式： public void com.test.service.UserServiceImpl.save() =》 * com.test.service.*ServiceImpl.*(..) public 为默认值可省略 返回值为任意值不做限定 *ServiceImpl 代表后缀名为 ServiceImpl 的都进行配置 *(..) 代表方法名任意，可包含参数 --&gt; &lt;aop:pointcut expression="execution(* com.test.service.*ServiceImpl.*(..))" id="pc"/&gt; &lt;aop:aspect ref="myAdvice"&gt; &lt;!-- 指定名为 before 的方法作为前置通知 --&gt; &lt;aop:before method="before" pointcut-ref="pc" /&gt; &lt;aop:after-returning method="afterReturning" pointcut-ref="pc"/&gt; &lt;aop:around method="around" pointcut-ref="pc"/&gt; &lt;aop:after method="after" pointcut-ref="pc"/&gt; &lt;aop:after-throwing method="afterException" pointcut-ref="pc"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试12345678910111213141516// Spring 帮我们创建容器@RunWith(SpringJUnit4ClassRunner.class)// 指定 spring 配置文件的路径@ContextConfiguration("classpath:com/test/e_annotationaop/applicationContext.xml")public class Demo &#123; // 将容器中名为 userService 的对象注入到 us 变量中 @Resource(name="userService") private UserService us; @Test public void fun1() &#123; us.save(); &#125; &#125; 使用注解配置前两步与 XML 配置方式相同。使用注解配置，首先需要在 spring 的配置文件中开启使用注解完成织入。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt; &lt;!-- 准备工作：导入 aop（约束）命名空间 --&gt; &lt;!-- 1. 配置目标对象 --&gt; &lt;bean name="userService" class="com.test.service.UserServiceImpl"&gt;&lt;/bean&gt; &lt;!-- 2. 配置通知对象 --&gt; &lt;bean name="myAdvice" class="com.test.d_springaop.MyAdvice"&gt;&lt;/bean&gt; &lt;!-- 开启使用注解完成织入 --&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 在通知类上添加注解12345678910111213141516171819202122232425262728293031323334353637383940414243// @Aspect 注解就是声明 MyAdivce 是一个通知类@Aspectpublic class MyAdvice &#123; // 获得切点表达式方法 @Pointcut("excution(* com.test.service.*ServiceImpl.*(..))") public void pc() &#123;&#125; // 前置通知 // 指定该方法为前置通知，并切入到指定的切入点当中 @Before("MyAdvice.pc()") public void before() &#123; System.out.println("这是前置通知!"); &#125; // 后置通知（出现异常不会调用） @AfterReturning("excution(* com.test.service.*ServiceImpl.*(..))") public void afterReturning() &#123; System.out.println("这是后置通知（出现异常不会调用）"); &#125; // 环绕通知 @Around("excution(* com.test.service.*ServiceImpl.*(..))") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("这是环绕通知之前的部分！"); Object proceed = pjp.proceed(); // 调用目标方法 System.out.println("这是环绕通知之后的部分！"); return proceed; &#125; // 异常通知 @AfterThrowing("excution(* com.test.service.*ServiceImpl.*(..))") public void afterException() &#123; System.out.println("出事啦，出现异常了！"); &#125; // 后置通知（出现异常也会继续调用） @After("excution(* com.test.service.*ServiceImpl.*(..))") public void after() &#123; System.out.println("这是后置通知（出现异常也会调用）!"); &#125; &#125; 测试12345678910111213141516// Spring 帮我们创建容器@RunWith(SpringJUnit4ClassRunner.class)// 指定 spring 配置文件的路径@ContextConfiguration("classpath:com/test/e_annotationaop/applicationContext.xml")public class Demo &#123; // 将容器中名为 userService 的对象注入到 us 变量中 @Resource(name="userService") private UserService us; @Test public void fun1() &#123; us.save(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring（一）]]></title>
    <url>%2Fspring_01%2F</url>
    <content type="text"><![CDATA[Spring 概述什么是 SpringSpring 是一个分层的一站式的轻量级的开源框架。 为什么学习 Spring 方便耦合，简化开发 AOP 编程的支持 声明市事务的支持 方便程序的测试 … Spring 的入门下载 Spring 开发包并解压http://spring.io/ 创建 web 项目，导入相应的 jar 包 创建实体类12345678910111213141516171819202122232425262728293031public class User &#123; private String name; private Integer age; private Car car; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Car getCar() &#123; return car; &#125; public void setCar(Car car) &#123; this.car = car; &#125; @Override public String toString() &#123; return "User [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125; &#125; 将实体类交给 Spring 管理12345&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd "&gt; &lt;!-- 将 User 对象交给 spring 容器管理 --&gt; &lt;bean name="user" class="com.test.bean.User"&gt;&lt;/bean&gt;&lt;/beans&gt; 编写测试类12345678910111213public class Demo &#123; @Test public void fun1() &#123; // 1. 创建容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml"); // 2. 向容器"要" user 对象 User user = (User) ac.getBean("user"); // 3. 打印 user 对象 System.out.println(user); &#125; &#125; Spring 相关概念IOCIOC：Inverse of Control，控制反转的意思。将我们创建对象的方式反转了，以前是由我们开发人员去自己维护，使用了 spring 以后，对象的创建以及依赖关系可以交给 spring 完成创建以及注入。 简单地说，反转控制就是反转了对象的创建方式，由原来的开发人员自己创建反转为了由 spring 程序创建。 DIDI：Dependency Injection，依赖注入的意思。实现 IOC 思想需要 DI 做支持。 ApplicationContext 和 BeanFactoryBeanFactory 接口是 Spring 的原始接口，功能比较单一，BeanFactory 接口实现类的容器的特点是：每次在获得对象时才会创建对象。（懒加载） ApplicationContext 接口每次容器启动时就会创建容器中配置的所有对象（立即加载），并提供更多的功能。 从类路径下加载配置文件使用的是 ClassPathXmlApplicationContext 实现类。 从硬盘绝对路径下加载配置文件使用的是 FileSystemXmlApplicationContext(“绝对路径”) 结论在 web 开发中，一般使用的是 ApplicationContext，在资源匮乏的时候可以使用 BeanFactory。 Bean 的相关配置Bean 标签的id和name的配置 Bean 元素：使用该元素描述需要 spring 容器管理的对象 属性 class：被管理对象的完整类名。 name：给被管理的对象的起一个名字，从 spring 容器中获得对象时，使用该名称获得。可以重复，可以使用特殊字符。（一般不会起重复的名字） id：与 name 属性一模一样。不可重复，不能包含特殊字符。 Bean 标签的声明周期的配置init-method：配置一个方法作为生命周期的初始化方法，spring 容器在创建之后会立即调用。 destory-method：配置一个方法作为生命周期的销毁方法，在 spring 容器关闭并销毁所有容器中的对象之前调用。 123456789// 对象创建后，容器会调用对象的 init 方法public void init() &#123; System.out.println("我是初始化方法！");&#125;// 容器关闭后，会调用对象的 destory 方法public void destory() &#123; System.out.println("我是销毁方法！");&#125; 1&lt;bean name="user" class="com.test.bean.User" init-method="init" destroy-method="destory"&gt;&lt;/bean&gt; Bean 标签的 scope 属性的取值singleton：默认值，单例对象，被标识为单例的对象在 spring 容器中只会存在一个实例。 prototype：多例原型，被标识为多例的对象，每次获得都会创建新的对象。 request：web 环境下，对象与 request 生命周期一致。 session：web 环境下，对象与 session 生命周期一致。 Spring 创建对象的方式空参构造方式12&lt;!-- 对象创建方式一：空参构造方法 --&gt;&lt;bean name="user" class="com.test.bean.User" init-method="init" destroy-method="destory" scope="singleton"&gt;&lt;/bean&gt; 静态工厂方式（了解）12345// 静态工厂方法public static User createUser() &#123; System.out.println("静态工厂方式创建 User..."); return new User();&#125; 12&lt;!-- 对象创建方式二：静态工厂方式 --&gt;&lt;bean name="user2" class="com.test.b_create.UserFactory" factory-method="createUser"&gt;&lt;/bean&gt; 实例工厂方式（了解）12345// 实例工厂方法public User createUser2() &#123; System.out.println("实例工厂方式创建 User..."); return new User();&#125; 1234&lt;!-- 对象创建方式三：实例工厂方式 --&gt;&lt;bean name="user3" factory-bean="userFactory" factory-method="createUser2"&gt;&lt;/bean&gt;&lt;!-- 配置实例工厂对象 --&gt;&lt;bean name="userFactory" class="com.test.b_create.UserFactory"&gt;&lt;/bean&gt; Spring 的分模块引入配置12&lt;!-- spring 的分模块配置，导入其他的配置文件 --&gt;&lt;import resource="com/test/b_create/applicationContext.xml"/&gt; Spring 的属性注入set 方法注入1234567891011121314151617&lt;!-- 将 User 对象交给 spring 容器管理 --&gt;&lt;!-- 1. set 方式注入： --&gt;&lt;bean name="user" class="com.test.bean.User"&gt; &lt;!-- 值类型注入： --&gt; &lt;!-- 为 User 中名为 name 的属性注入 tom 作为值 --&gt; &lt;property name="name" value="tom"&gt;&lt;/property&gt; &lt;!-- 为 User 中名为 age 的属性注入 18 作为值 --&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;!-- 引用类型注入 --&gt; &lt;property name="car" ref="car"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 将 Car 对象交给 spring 容器管理 --&gt;&lt;bean name="car" class="com.test.bean.Car"&gt; &lt;property name="name" value="玛莎拉蒂"&gt;&lt;/property&gt; &lt;property name="color" value="黄色"&gt;&lt;/property&gt;&lt;/bean&gt; 构造函数注入1234567891011&lt;!-- 2. 构造方法注入： --&gt;&lt;bean name="user2" class="com.test.bean.User"&gt; &lt;!-- 配置构造方法的参数 name 属性 ：构造函数参数的名字 index 属性 ：构造函数的参数的索引位置 type 属性 ：构造函数的参数的类型 --&gt; &lt;constructor-arg name="name" value="999" index="0" type="java.lang.Integer"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="car" ref="car"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; p 名称空间注入123456789&lt;!-- 3. p 名称空间注入 ，其实走的是 set 方式 （1）导入名称空间 xmlns:p="http://www.springframework.org/schema/beans/p" （2）使用 p:属性 完成注入 值类型：p:属性名="属性值" 对象类型：p:对象名-ref="bean名称" --&gt;&lt;bean name="user3" class="com.test.bean.User" p:name="jerry" p:age="20" p:car-ref="car"&gt;&lt;/bean&gt; spel 注入123456&lt;!-- 4. spel 注入：spring expression language（Spring 表达式语言）--&gt;&lt;bean name="user4" class="com.test.bean.User"&gt; &lt;property name="name" value="#&#123;user.name&#125;"&gt;&lt;/property&gt; &lt;property name="age" value="#&#123;user2.name&#125;"&gt;&lt;/property&gt; &lt;property name="car" ref="car"&gt;&lt;/property&gt;&lt;/bean&gt; 复杂类型注入数组类型注入1234567891011&lt;!-- 1. array 数组类型注入 --&gt;&lt;!-- 如果数组中只包含一个值或一个对象 --&gt;&lt;!-- &lt;property name="arr" value="tom"&gt;&lt;/property&gt; --&gt;&lt;!-- 如果数组中包含多个值或对象 --&gt;&lt;property name="arr"&gt; &lt;array&gt; &lt;value&gt;tom&lt;/value&gt; &lt;value&gt;jack&lt;/value&gt; &lt;ref bean="user"/&gt; &lt;/array&gt;&lt;/property&gt; List 类型注入1234567891011&lt;!-- 2. list 集合注入 --&gt;&lt;!-- 如果 list 中只包含一个值或一个对象 --&gt;&lt;!-- &lt;property name="list" value="tom"&gt;&lt;/property&gt; --&gt;&lt;!-- 如果 list 中包含多个值或对象 --&gt;&lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;tom&lt;/value&gt; &lt;value&gt;jack&lt;/value&gt; &lt;ref bean="user"/&gt; &lt;/list&gt;&lt;/property&gt; Map 类型注入123456789&lt;!-- 3. map 集合注入 --&gt;&lt;property name="map"&gt; &lt;map&gt; &lt;!-- map 的键和值可以是任意类型的 --&gt; &lt;entry key="name" value="tom"&gt;&lt;/entry&gt; &lt;entry key="user2" value-ref="user2"&gt;&lt;/entry&gt; &lt;entry key-ref="user3" value-ref="user4"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; Properties 类型注入123456789&lt;!-- 4. properties 类型注入 --&gt;&lt;property name="prop"&gt; &lt;props&gt; &lt;!-- properties 中键和值的类型都是字符串 --&gt; &lt;prop key="url"&gt;jdbc:mysql:///crm&lt;/prop&gt; &lt;prop key="username"&gt;root&lt;/prop&gt; &lt;prop key="password"&gt;1&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 将 spring 容器应用到项目中导入相应的 jar 包将 Service 对象和 Dao 对象配置到 spring 容器中123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd "&gt; &lt;!-- 配置 dao --&gt; &lt;bean name="customerDao" class="com.test.dao.impl.CustomerDaoImpl"&gt;&lt;/bean&gt; &lt;bean name="userDao" class="com.test.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;!-- 配置 service --&gt; &lt;bean name="customerService" class="com.test.service.impl.CustomerServiceImpl"&gt; &lt;property name="customerDao" ref="customerDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name="userService" class="com.test.service.impl.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在 web.xml 中配置 ContextLoaderListener 监听器，并指定加载 spring 配置文件的位置123456789&lt;!-- 配置一个监听器，可以让 spring 容器随项目的启动而启动，随项目的关闭而销毁 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 使用 context-param 指定加载的 spring 配置文件的名称和位置 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 在 Action 中获得容器中的对象1234567// 获得 spring 容器 -- 从 application 域中获得// 获得 ServletContext 对象ServletContext sc = ServletActionContext.getServletContext();// 获得 spring 容器对象WebApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc);// 从容器中获得 CustomerServiceCustomerService customerService = (CustomerService) ac.getBean("customerService");]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2（四）]]></title>
    <url>%2Fstruts2_04%2F</url>
    <content type="text"><![CDATA[Struts2 的拦截器拦截器概述什么是拦截器动态拦截 Action 调用的对象。 Filter 和 Inteceptor 的区别Filter：过滤器，过滤从客户端向服务器发送的请求。 Interceptor：拦截器。拦截的是客户端对 Action 的访问，更加细粒度化的拦截。 Struts2 的执行流程客户端向服务器发送一个 Action 的请求，执行核心过滤器 doFilter() 方法，在这个方法中，调用 executeAction() 方法，在这个方法内部调用 dispatcher.serviceAction() 方法，在这个方法内部创建一个 Action 代理，最终执行的是 Action 代理中的 execute() 方法，在代理中执行的 execute() 方法中调用 ActionInvocation 的 invoke 方法。在这个方法内部递归执行一组拦截器，如果没有下一个拦截器的话，就执行目标 Action，根据 Action 的返回的结果进行页面跳转。 拦截器入门编写拦截器类12345678910111213141516/** * 自定义拦截器一 * @author Tong * */public class InteceptorDemo1 extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println("InterceptorDemo1 执行了..."); String invoke = invocation.invoke(); System.out.println("InterceptorDemo1 结束了..."); return invoke; &#125; &#125; 配置拦截器 有两种配置方式 自定义拦截器，引入拦截器1234567891011121314151617&lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 自定义拦截器 === 配置方式一--&gt; &lt;interceptors&gt; &lt;interceptor name="InterceptorDemo1" class="com.test.web.interceptor.InteceptorDemo1" /&gt; &lt;interceptor name="InterceptorDemo2" class="com.test.web.interceptor.InteceptorDemo2" /&gt; &lt;/interceptors&gt; &lt;action name="actionDemo1" class="com.test.web.action.ActionDemo1"&gt; &lt;result&gt;/demo1/demo1.jsp&lt;/result&gt; &lt;!-- 引入自定义拦截器（自定义拦截器之后默认拦截器就不执行了，如果需要一定要手动引入默认拦截器栈中的拦截器） --&gt; &lt;interceptor-ref name="defaultStack" /&gt; &lt;interceptor-ref name="InterceptorDemo1" /&gt; &lt;interceptor-ref name="InterceptorDemo2" /&gt; &lt;/action&gt;&lt;/package&gt; 自定义拦截器栈，引入拦截器栈123456789101112131415161718192021&lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 自定义拦截器栈 === 配置方式二--&gt; &lt;interceptors&gt; &lt;interceptor name="InterceptorDemo1" class="com.test.web.interceptor.InteceptorDemo1" /&gt; &lt;interceptor name="InterceptorDemo2" class="com.test.web.interceptor.InteceptorDemo2" /&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack" /&gt; &lt;interceptor-ref name="InterceptorDemo1" /&gt; &lt;interceptor-ref name="InterceptorDemo2" /&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;action name="actionDemo1" class="com.test.web.action.ActionDemo1"&gt; &lt;result&gt;/demo1/demo1.jsp&lt;/result&gt; &lt;!-- 引入自定义拦截器栈 --&gt; &lt;interceptor-ref name="myStack" /&gt; &lt;/action&gt;&lt;/package&gt; CRM 权限拦截器案例实现用户登录功能创建数据库表和实体创建表12345678CREATE TABLE `sys_user` ( `user_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '用户id', `user_code` varchar(32) NOT NULL COMMENT '用户账号', `user_name` varchar(64) NOT NULL COMMENT '用户名称', `user_password` varchar(32) NOT NULL COMMENT '用户密码', `user_state` char(1) NOT NULL COMMENT '1:正常,0:暂停', PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建实体1234567891011121314151617181920212223242526272829303132333435363738394041424344public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; public Long getUser_id() &#123; return user_id; &#125; public void setUser_id(Long user_id) &#123; this.user_id = user_id; &#125; public String getUser_code() &#123; return user_code; &#125; public void setUser_code(String user_code) &#123; this.user_code = user_code; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getUser_password() &#123; return user_password; &#125; public void setUser_password(String user_password) &#123; this.user_password = user_password; &#125; public String getUser_state() &#123; return user_state; &#125; public void setUser_state(String user_state) &#123; this.user_state = user_state; &#125; @Override public String toString() &#123; return "User [user_id=" + user_id + ", user_code=" + user_code + ", user_name=" + user_name + ", user_password=" + user_password + ", user_state=" + user_state + "]"; &#125; &#125; Action 类12345678910111213141516171819202122232425262728293031323334353637/** * 用户的 Action 类 * @author Tong * */public class UserAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; // 接收数据封装数据 private User user = new User(); @Override public User getModel() &#123; return user; &#125; /** * 用户的登录方法 */ public String login() &#123; //System.out.println(user); // 调用 service 层的登录方法 UserService userService = new UserServiceImpl(); User existUser = userService.login(user); // 判断该用户是否存在，进行页面跳转 if (existUser != null) &#123; // 如果存在，跳转到 index.jsp 页面，并将该 user 对象存到 session 域中 ServletActionContext.getRequest().getSession().setAttribute("user", existUser); return SUCCESS; &#125; else &#123; // 如果不存在，跳转到登录页面 // 添加错误信息，写回到页面上 addActionError("用户名或密码错误!"); return LOGIN; &#125; &#125;&#125; Service 层实现类12345678910111213141516/** * 用户的业务层的接口的实现类 * @author Tong * */public class UserServiceImpl implements UserService &#123; @Override // 用户 service 层的登录方法 public User login(User user) &#123; // 调用 dao 层的登录方法 UserDao userDao = new UserDaoImpl(); return userDao.login(user); &#125;&#125; Dao 层实现类1234567891011121314151617181920212223242526272829/** * 用户的 dao 层接口的实现类 * @author Tong * */public class UserDaoImpl implements UserDao &#123; @Override // 用户 dao 层的登录方法 public User login(User user) &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 根据用户名和密码查询该用户是否存在 Query query = session.createQuery("from User where user_code=? and user_password=?"); // 设置参数 query.setParameter(0, user.getUser_code()); query.setParameter(1, user.getUser_password()); User existUser = (User) query.uniqueResult(); // 如果该用户存在，返回该用户 if (existUser != null) &#123; return existUser; &#125; tx.commit(); // 如果不存在，返回 null return null; &#125;&#125; 根据结果进行页面跳转1234567&lt;!-- 配置用户的 action --&gt;&lt;action name="user_*" class="com.test.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;!-- 登录成功 --&gt; &lt;result name="success" type="redirect"&gt;/index.jsp&lt;/result&gt; &lt;!-- 登录失败 --&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt;&lt;/action&gt; 实现权限拦截器编写拦截器类12345678910111213141516171819202122232425/** * 自定义权限控制拦截器 * @author Tong * */public class PrivilegeInteceptor extends MethodFilterInterceptor &#123; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; // 获得 Session User user = (User) ServletActionContext.getRequest().getSession().getAttribute("user"); // 判断 session 中是否包含 user 对象 if (user != null) &#123; // 如果包含，放行 return invocation.invoke(); &#125; else &#123; // 如果不包含，拦截 // 跳转到登录页面，给出提示信息 ActionSupport actionSupport = (ActionSupport) invocation.getAction(); actionSupport.addActionError("用户未登录，没有权限进行以下操作！"); return actionSupport.LOGIN; &#125; &#125;&#125; 配置拦截器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 配置Struts2的常量 --&gt; &lt;constant name="struts.action.extension" value="action"/&gt; &lt;package name="crm" extends="struts-default" namespace="/"&gt; &lt;!-- 配置自定义拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name="privilegeInteceptor" class="com.test.web.interceptor.PrivilegeInteceptor"/&gt; &lt;/interceptors&gt; &lt;!-- 配置全局结果页面 --&gt; &lt;global-results&gt; &lt;!-- LOGIN --&gt; &lt;result name="login"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;!-- 配置客户的 action --&gt; &lt;action name="customer_*" class="com.test.web.action.CustomerAction" method="&#123;1&#125;"&gt; &lt;result name="findSuccess"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;result name="saveUI"&gt;/jsp/customer/add.jsp&lt;/result&gt; &lt;result name="saveSuccess" type="redirectAction"&gt;customer_find.action&lt;/result&gt; &lt;!-- 引入拦截器配置 --&gt; &lt;interceptor-ref name="privilegeInteceptor"&gt; &lt;!-- 不拦截 login 方法，其他方法都拦截 --&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/action&gt; &lt;!-- 配置用户的 action --&gt; &lt;action name="user_*" class="com.test.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;!-- 登录成功 --&gt; &lt;result name="success" type="redirect"&gt;/index.jsp&lt;/result&gt; &lt;!-- 登录失败 --&gt; &lt;!-- &lt;result name="login"&gt;/login.jsp&lt;/result&gt; --&gt; &lt;!-- 引入拦截器配置 --&gt; &lt;interceptor-ref name="privilegeInteceptor"&gt; &lt;!-- 不拦截 login 方法，其他方法都拦截 --&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; Struts2 的标签库通用标签库 常用的标签有判断标签、迭代标签、property 标签和 debug 标签 判断标签12345678910&lt;s:set var="i" value="3" scope="request"&gt;&lt;/s:set&gt;&lt;s:if test="#request.i&gt;3"&gt; i 大于 3&lt;/s:if&gt;&lt;s:elseif test="#request.i&lt;3"&gt; i 小于 3&lt;/s:elseif&gt;&lt;s:else&gt; i 等于 3&lt;/s:else&gt; 迭代标签1234567&lt;s:iterator value="#&#123;'aa':'11','bb':'22','cc':'33'&#125;"&gt; &lt;s:property value="key" /&gt;---&lt;s:property value="value" /&gt;&lt;/s:iterator&gt;&lt;hr&gt;&lt;s:iterator begin="1" end="100" step="1" status="status"&gt; &lt;s:property value="#status.count"/&gt;&lt;/s:iterator&gt; UI 标签库 传统标签和 UI 标签的对比 12345678910111213141516171819202122232425262728293031&lt;h3&gt;传统标签&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/uiAction.action" method="post"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 密码：&lt;input type="password" name="password"/&gt;&lt;br/&gt; 年龄：&lt;input type="text" name="age"/&gt;&lt;br/&gt; 性别：&lt;input type="radio" name="sex" value="女"/&gt;男 &lt;input type="radio" name="sex" value="女"/&gt;女&lt;br/&gt; 籍贯：&lt;select name="city"&gt; &lt;option value=""&gt;--请选择--&lt;/option&gt; &lt;option value="北京"&gt;北京&lt;/option&gt; &lt;option value="上海"&gt;上海&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 爱好：&lt;input type="checkbox" name="hobby" value="basketball"/&gt;篮球 &lt;input type="checkbox" name="hobby" value="football"/&gt;足球 &lt;input type="checkbox" name="hobby" value="volleyball"/&gt;排球 &lt;br/&gt; 自我介绍：&lt;textarea rows="2" cols="10" name="info"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;&lt;h3&gt;UI 标签&lt;/h3&gt;&lt;s:form action="uiAction" namespace="/" method="post"&gt; &lt;s:textfield name="username" label="用户名"/&gt; &lt;s:password name="password" label="密码" showPassword="true"/&gt; &lt;s:textfield name="age" label="年龄"/&gt; &lt;s:radio list="&#123;'男','女'&#125;" name="sex" label="性别"/&gt; &lt;s:select list="&#123;'北京','上海'&#125;" name="city" label="籍贯" headerKey="" headerValue="--请选择--"/&gt; &lt;s:checkboxlist list="#&#123;'basketball':'篮球','football':'足球','volleyball':'排球' &#125;" name="hobby" label="爱好" /&gt; &lt;s:textarea name="info" rows="2" cols="10" label="自我介绍"&gt;&lt;/s:textarea&gt; &lt;s:submit value="提交"/&gt;&lt;/s:form&gt; 学习目标学会自定义拦截器并配置以及一些常用标签的使用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2（三）]]></title>
    <url>%2Fstruts2_03%2F</url>
    <content type="text"><![CDATA[OGNL 的概述什么是 OGNLOGNL（Object-Graph Navigation Language） 的全称是对象导航语言，可以用来存取 Java 对象的任何属性，调用 Java 对象的方法，是一种功能强大的开源表达式语言。 OGNL 的作用OGNL 是 Struts2 默认的表达式语言。它具有一下特点： 支持对象方法调用。 支持类静态方法调用和值访问。 支持赋值操作和表达式串联。 可以访问 OgnlContext 和 ActionContext 对象。 操作集合对象。 OGNL 的要素表达式、根对象（Root）、Context 对象。 OGNL 的入门在 Java 环境下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Ognl 表达式在 Java 环境下的使用 * @author Tong * */public class OgnlDemo1 &#123; @Test /** * 使用 Ognl 表达式访问对象的方法 */ public void demo1() throws OgnlException &#123; // 获得 context 对象 OgnlContext context = new OgnlContext(); // 获得根对象 Object root = context.getRoot(); // 书写并执行表达式 Object obj = Ognl.getValue("'helloworld'.length()", context, root); // 获取字符串的长度 System.out.println(obj); &#125; @Test /** * 使用 Ognl 表达式访问静态方法 */ public void demo2() throws OgnlException &#123; // 获得 context 对象 OgnlContext context = new OgnlContext(); // 获得根对象 Object root = context.getRoot(); // 书写并执行表达式 // 表达式书写规则：@类名@静态方法名 Object obj = Ognl.getValue("@java.lang.Math@random()", context, root); // 调用 Math 类的 random 方法生成一个 0-1 的随机数 System.out.println(obj); &#125; @Test /** * 向 root 对象中存入数据，并获取，获取时不需要加 # 号 */ public void demo3() throws OgnlException &#123; // 获得 context 对象 OgnlContext context = new OgnlContext(); // 向 root 中存入一个对象 User user = new User("张三", "123"); context.setRoot(user); // 获得根对象 Object root = context.getRoot(); // 书写并执行表达式 Object username = Ognl.getValue("username", context, root); Object password = Ognl.getValue("password", context, root); System.out.println(username + " " + password); &#125; @Test /** * 向 context 对象中存入数据，并获取，获取时需要加 # 号 */ public void demo4() throws OgnlException &#123; // 获得 context 对象 OgnlContext context = new OgnlContext(); context.put("name", "李四"); // 获得根对象 Object root = context.getRoot(); // 执行表达式获取数据 Object obj = Ognl.getValue("#name", context, root); System.out.println(obj); &#125;&#125; 在 Struts2 环境下1234567&lt;h1&gt;Ognl 在 Struts2 环境的入门&lt;/h1&gt;&lt;h3&gt;使用 Ognl 表达式调用对象的方法&lt;/h3&gt;&lt;s:property value="'helloworld'.length()" /&gt;&lt;h3&gt;使用 Ognl 表达式调用静态方法&lt;/h3&gt;&lt;!-- 默认情况下，Struts2 关闭了静态方法的访问，需要修改一个常量的值开启 --&gt;&lt;s:property value="@java.lang.Math@random()" /&gt; 值栈的概述什么是值栈ValueStack是 Struts 的一个接口，中文意思就是值栈。OgnlValueStack 是 ValueStack 的实现类，当客户端发送一个请求后，struts2 架构会构建一个 action 实例同时创建一个 OgnlValueStack 值栈实例，OgnlValueStack 贯穿整个 Action 的生命周期，struts2 中使用 OGNL 将请求 Action 的参数封装为对象存储到值栈中，并通过 OGNL 表达式读取值栈中的对象属性值。 值栈的内部结构在 OgnlValueStack 中主要包括两部分，一部分是 root，其实 root 就是一个 ArrayList 集合，另一部分是 context，其实 context 就是一个 Map。 ActionContext 和 ValueStack 的关系在创建 ActionContext 的时候会创建 ValueStack 的对象，并将 ValueStack 对象传给 ActionContext，ActionContext 中就有一个 ValueStack 的引用。ValueStack 中也有一个 ActionContext 的引用。 获得值栈对象通过 ActionContext 对象获得值栈12// 第一种：获得值栈ValueStack valueStack = ActionContext.getContext().getValueStack(); 通过 request 域获得值栈12// 第二种：通过 ServletActionContext 对象获得Object valueStack2 = ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 操作值栈对 Action 中的属性提供 get 方法的方式1234567891011121314151617public class ValueStackDemo3 extends ActionSupport &#123; // 提供属性和 get 方法 private User user; public User getUser() &#123; return user; &#125; @Override public String execute() throws Exception &#123; // 向 ValueStack 中存入数据 user = new User("张三", "111"); return SUCCESS; &#125; &#125; 手动操作值栈，使用 push 和 set 方法1234567891011121314151617public class ValueStackDemo4 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 获得值栈对象 ValueStack valueStack = ActionContext.getContext().getValueStack(); // 向值栈中存入数据 User user = new User(&quot;李四&quot;, &quot;222&quot;); // 使用 push 方法 valueStack.push(user); // 使用 set 方法 valueStack.set(&quot;name&quot;, &quot;王五&quot;); return super.execute(); &#125; &#125; 从值栈中获取数据123456789101112131415161718&lt;!-- 获取一个对象 --&gt;&lt;s:property value="username" /&gt;&lt;s:property value="password" /&gt;&lt;br&gt;&lt;!-- 获取一个 List 集合 --&gt;&lt;s:property value="list[0].username" /&gt;&lt;s:property value="list[0].password" /&gt;&lt;br&gt;&lt;s:property value="list[1].username" /&gt;&lt;s:property value="list[1].password" /&gt;&lt;br&gt;&lt;s:property value="list[2].username" /&gt;&lt;s:property value="list[2].password" /&gt;&lt;br&gt;&lt;!-- 获得 context 区域中的数据 --&gt;&lt;s:property value="#request.name" /&gt;&lt;s:property value="#session.name" /&gt;&lt;s:property value="#application.name" /&gt;&lt;s:property value="#attr.name" /&gt;&lt;s:property value="#parameters.id" /&gt; 为什么 EL 表达式能够访问值栈因为底层对 Request 对象的 getAttribute 方法进行了增强，先会从域当中获得值，如果获取不到就会去值栈中获取。 OGNL 的特殊字符的使用# 号的使用 获得 context 的数据 &lt;s:property value=&quot;#request.name&quot;/&gt; 用于构建一个 Map 集合 12345&lt;s:iterator value="#&#123;'aa':'11','bb':'22','cc':'33' &#125;"&gt; &lt;s:property value="key" /&gt;--&lt;s:property value="value" /&gt;&lt;br/&gt;&lt;/s:iterator&gt;&lt;!--快捷创建单选按钮--&gt;&lt;s:radio list="#&#123;'1':'男','2':'女'&#125;" name="sex2" label="性别" /&gt; % 的使用 强制解析 OGNL 表达式 1&lt;s:textfield name="name" value="%&#123;#request.name&#125;" /&gt; 强制不解析 OGNL 表达式 1&lt;s:property value="%&#123;'#request.name'&#125;" /&gt; $ 号的使用在 struts 的配置文件或者是属性文件中会使用。 CRM 查询优化Action 类中的查询方法 12345678910111213141516/** * 查询客户列表的方法 * @return */public String find() &#123; CustomerService customerService = new CustomerServiceImpl(); List&lt;Customer&gt; list = customerService.find(); // 获得 request 对象，将获取到的数据放到域中返回到页面上 // ServletActionContext.getRequest().setAttribute("list", list); // 将查询到的 list 集合放到值栈中 ActionContext.getContext().getValueStack().set("list", list); return "findSuccess";&#125; 使用 OGNL 表达式遍历显示在页面上 12345678910111213141516&lt;s:iterator value="list"&gt; &lt;TR style="FONT-WEIGHT: normal; FONT-STYLE: normal; BACKGROUND-COLOR: white; TEXT-DECORATION: none"&gt; &lt;TD&gt;&lt;s:property value="cust_name"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value="cust_level"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value="cust_source"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value="cust_industry"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value="cust_phone"/&gt;&lt;/TD&gt; &lt;TD&gt;&lt;s:property value="cust_mobile"/&gt;&lt;/TD&gt; &lt;TD&gt; &lt;a href="$&#123;pageContext.request.contextPath &#125;"&gt;修改&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href="$&#123;pageContext.request.contextPath &#125;"&gt;删除&lt;/a&gt; &lt;/TD&gt; &lt;/TR&gt;&lt;/s:iterator&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2（二）]]></title>
    <url>%2Fstruts2_02%2F</url>
    <content type="text"><![CDATA[Struts2 访问 Servlet 的 API 在使用 Struts2 框架的过程中，我们发现 Struts2 和 Servlet 的解耦合的，但是在实际的开发中，经常会使用到 Servlet 中的 API，那么就必须学习 Struts2 如何访问 Servlet 中的 API 了。 使用完全解耦方式访问JSP 页面部分123456&lt;h3&gt;方式一：使用完全解耦合的方式访问&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/requestDemo1.action" method="post"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; 密码：&lt;input type="password" name="password"/&gt;&lt;br&gt; &lt;input type="submit" value="提交" /&gt;&lt;br&gt;&lt;/form&gt; 编写 Action 类1234567891011121314151617181920212223242526272829public class RequestDemo1 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 一、接收参数 // 利用 Struts2 中的 ActionContext 对象 ActionContext context = ActionContext.getContext(); // 调用 ActionContext 中的方法获得参数，类似于 request.getParameter() Map&lt;String, Object&gt; map = context.getParameters(); // 遍历 map for (String key : map.keySet()) &#123; String[] value = (String[]) map.get(key); System.out.println(key + " " + Arrays.toString(value)); &#125; // 二、向域对象中存入数据 // 向 request 域中存数据 context.put("reqName", "reqValue"); // 相当于 request.setAttribute() // 向 session 域中存数据 context.getSession().put("sessName", "sessValue"); // 相当于 session.setAttribute() // 向 application 域中存数据 context.getApplication().put("appName", "appValue");// 相当于 application.setAttribute() return SUCCESS; &#125; &#125; 注意这种方式只能获取代表 request、session、application 的数据的 Map 集合。不能操作这些对象的中的方法。 使用 Servlet 的 API 的原生方式访问JSP 页面部分123456&lt;h3&gt;方式二：使用 Servlet 原生的方式访问&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/requestDemo2.action" method="post"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; 密码：&lt;input type="password" name="password"/&gt;&lt;br&gt; &lt;input type="submit" value="提交" /&gt;&lt;br&gt;&lt;/form&gt; 编写 Action 类1234567891011121314151617181920212223242526272829public class RequestDemo2 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; // 一、接收参数 // 使用 ServletActionContext 获得 request 对象 HttpServletRequest request = ServletActionContext.getRequest(); // 接收参数 Map&lt;String, String[]&gt; map = request.getParameterMap(); // 遍历 map，获得 name 和 value for (String key : map.keySet()) &#123; String[] strings = map.get(key); System.out.println(key + " " + Arrays.toString(strings)); &#125; // 二、向域对象中保存数据 // 向 request 域中存数据 request.setAttribute("reqName", "reqValue"); // 向 session 域中存数据 request.getSession().setAttribute("sessName", "sessValue"); // 向 ServletContext 域中存数据 request.getServletContext().setAttribute("appName", "appValue"); //ServletActionContext.getServletContext().setAttribute("appName", "appValue"); return SUCCESS; &#125; &#125; 注意这种方式即可以操作域对象的数据，同时也可以获得对象的方法。 使用接口注入的方式访问JSP 页面部分123456&lt;h3&gt;方式三：使用接口注入的方式访问&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/requestDemo3.action" method="post"&gt; 姓名：&lt;input type="text" name="name"/&gt;&lt;br&gt; 密码：&lt;input type="password" name="password"/&gt;&lt;br&gt; &lt;input type="submit" value="提交" /&gt;&lt;br&gt;&lt;/form&gt; 编写 Action 类123456789101112131415161718192021222324252627282930313233public class RequestDemo3 extends ActionSupport implements ServletRequestAware &#123; private HttpServletRequest request; @Override public String execute() throws Exception &#123; // 一、接收参数 // 通过接口注入的方式获得 request 对象 Map&lt;String, String[]&gt; map = request.getParameterMap(); // 遍历 map，获得 name 和 value for (String key : map.keySet()) &#123; String[] strings = map.get(key); System.out.println(key + " " + Arrays.toString(strings)); &#125; // 二、向域对象中保存数据 // 向 request 域中存数据 request.setAttribute("reqName", "reqValue"); // 向 session 域中存数据 request.getSession().setAttribute("sessName", "sessValue"); // 向 application 域中存数据 request.getServletContext().setAttribute("appName", "appValue"); return super.execute(); // SUCCESS &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; &#125; 注意Servlet 是单例的，多个程序访问同一个 Servlet 只会创建一个，所以存在线程安全问题。而 Action 是多例的，一次请求，创建一个 Action 的实例，不存在线程安全问题。 Struts2 的结果页面的配置结果页面的配置全局结果页面的配置全局结果页面指的是在这个包中配置一次，那么其他在这个包下的所有的 action 只要返回了这个值都会发现页面跳转。 作用范围：针对这个包下的所有的 action 都有效。 1234&lt;!-- 配置全局结果页面 --&gt;&lt;global-results&gt; &lt;result name="success"&gt;/demo1/demo2.jsp&lt;/result&gt;&lt;/global-results&gt; 局部结果页面的配置局部结果页面指的是只能在当前 action 中生效。 作用范围：仅对当前 action 有效。 12&lt;action name="requestDemo3" class="com.test.struts2.demo1.RequestDemo3"&gt;&lt;/action&gt; Result 标签的配置result 标签用于配置页面的跳转，result 标签的两个属性 name ：逻辑视图的名称。默认值为 success type ：页面跳转的类型 取值： dispatcher ：默认值。请求转发（Action 转发到 JSP） redirect ：重定向。（Action 重定向到 JSP） chain ：转发。（Action 转发到 Action） redirect ：重定向。（Action 重定向到 Action） stream ：Struts2 提供文件下载的功能 1234&lt;action name="requestDemo1" class="com.test.struts2.demo1.RequestDemo1"&gt; &lt;!-- 配置局部结果页面 --&gt; &lt;result type="redirect"&gt;/demo1/demo2.jsp&lt;/result&gt;&lt;/action&gt; Struts2 的数据的封装 Struts2 框架是一个 web 层框架，它提供了强大的数据封装的功能。 Struts2 的数据封装属性驱动方式提供属性和 set 方法的方式（不常用）JSP 页面部分 123456789&lt;h3&gt;方式一：属性驱动-提供 set 方法的方式&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/userAction1.action" method="post"&gt;用户名：&lt;input type="text" name="username" /&gt;&lt;br&gt;密码：&lt;input type="password" name="password" /&gt;&lt;br&gt;年龄：&lt;input type="text" name="age" /&gt;&lt;br&gt;生日：&lt;input type="text" name="birthday" /&gt;&lt;br&gt;薪水：&lt;input type="text" name="salary" /&gt;&lt;br&gt;&lt;input type="submit" value="提交"/&gt;&lt;br&gt;&lt;/form&gt; 编写 Action 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class UserAction1 extends ActionSupport &#123; // 提供属性和 set 方法 private String username; private String password; private Integer age; private Date birthday; private Double salary; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void setSalary(Double salary) &#123; this.salary = salary; &#125; @Override public String execute() throws Exception &#123; // 接收数据 System.out.println(username); System.out.println(password); System.out.println(age); System.out.println(birthday); System.out.println(salary); // 封装数据 User user = new User(); user.setUsername(username); user.setPassword(password); user.setAge(age); user.setBirthday(birthday); user.setSalary(salary); return NONE; &#125; &#125; 页面中提供表达式的方式JSP 页面部分 123456789&lt;h3&gt;方式二：属性驱动-在页面提供表达式的方式&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/userAction2.action" method="post"&gt;用户名：&lt;input type="text" name="user.username" /&gt;&lt;br&gt;密码：&lt;input type="password" name="user.password" /&gt;&lt;br&gt;年龄：&lt;input type="text" name="user.age" /&gt;&lt;br&gt;生日：&lt;input type="text" name="user.birthday" /&gt;&lt;br&gt;薪水：&lt;input type="text" name="user.salary" /&gt;&lt;br&gt;&lt;input type="submit" value="提交"/&gt;&lt;br&gt;&lt;/form&gt; 编写 Action类 123456789101112131415161718192021public class UserAction2 extends ActionSupport &#123; // 创建一个私有的 User 对象 private User user; // 提供 set 和 get 方法。get 方法必须提供，因为拦截器完成数据封装，需要创建对象，使用 get 方法可以获得到同一个对象，就可以将数据封装到同一个对象中。 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; 模型驱动方式（最常用）JSP 页面部分 123456789&lt;h3&gt;方式三：模型驱动-模型驱动的方式&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/userAction3.action" method="post"&gt;用户名：&lt;input type="text" name=username" /&gt;&lt;br&gt;密码：&lt;input type="password" name="password" /&gt;&lt;br&gt;年龄：&lt;input type="text" name="age" /&gt;&lt;br&gt;生日：&lt;input type="text" name="birthday" /&gt;&lt;br&gt;薪水：&lt;input type="text" name="salary" /&gt;&lt;br&gt;&lt;input type="submit" value="提交"/&gt;&lt;br&gt;&lt;/form&gt; 编写 Action 类 123456789101112131415161718public class UserAction3 extends ActionSupport implements ModelDriven&lt;User&gt; &#123; // 使用模型驱动的方式需提前手动创建一个对象的实例 private User user = new User(); // 模型驱动需要使用的方法 @Override public User getModel() &#123; return user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; INPUT 逻辑视图在 Action 接口中提供了五个逻辑视图的名称 SUCCESS ERROR LOGIN INPUT NONE 在 Struts2 框架底层的存储区域中有一块专门存储错误信息的区域，当出现错误的时候，Struts2 会把错误信息存储到这块区域中，最后拦截器检查这块区域中是否有错误信息，如果没有，直接执行目标 Action 对象，如果有的话，就会跳转到 INPUT 逻辑视图，那么如果在先前没有配置 INPUT 逻辑视图的话，默认就会报错提示你。 INPUT 逻辑视图的配置如果出现错误，则跳转页面到 demo1.jsp 中 123&lt;global-results&gt; &lt;result name="input"&gt;/demo2/demo1.jsp&lt;/result&gt;&lt;/global-results&gt; Struts2 的复杂类型的数据封装封装数据到 List 集合中JSP 页面部分12345678910&lt;h3&gt;封装到 List 集合中：批量插入商品&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/productAction1.action" method="post"&gt; 商品名称：&lt;input type="text" name="products[0].name"&gt;&lt;br&gt; 商品价格：&lt;input type="text" name="products[0].price"&gt;&lt;br&gt; 商品名称：&lt;input type="text" name="products[1].name"&gt;&lt;br&gt; 商品价格：&lt;input type="text" name="products[1].price"&gt;&lt;br&gt; 商品名称：&lt;input type="text" name="products[2].name"&gt;&lt;br&gt; 商品价格：&lt;input type="text" name="products[2].price"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 编写 Action 类123456789101112131415161718192021222324public class ProductAction1 extends ActionSupport &#123; /** * 使用的是页面表达式的方式封装数据 */ private List&lt;Product&gt; products; // 提供 set 和 get 方法 public List&lt;Product&gt; getProducts() &#123; return products; &#125; public void setProducts(List&lt;Product&gt; products) &#123; this.products = products; &#125; @Override public String execute() throws Exception &#123; for (Product product : products) &#123; System.out.println(product); &#125; return NONE; &#125; &#125; 封装数据到 Map 集合中JSP 页面部分12345678910&lt;h3&gt;封装到 Map 集合中：批量插入商品&lt;/h3&gt;&lt;form action="$&#123; pageContext.request.contextPath &#125;/productAction2.action" method="post"&gt; 商品名称：&lt;input type="text" name="map['one'].name"&gt;&lt;br&gt; 商品价格：&lt;input type="text" name="map['one'].price"&gt;&lt;br&gt; 商品名称：&lt;input type="text" name="map['two'].name"&gt;&lt;br&gt; 商品价格：&lt;input type="text" name="map['two'].price"&gt;&lt;br&gt; 商品名称：&lt;input type="text" name="map['three'].name"&gt;&lt;br&gt; 商品价格：&lt;input type="text" name="map['three'].price"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 编写 Action 类123456789101112131415161718192021222324public class ProductAction2 extends ActionSupport &#123; // 提供一个私有的 Map 对象 private Map&lt;String, Product&gt; map; // 提供 set 和 get 方法 public Map&lt;String, Product&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Product&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; for (String key : map.keySet()) &#123; Product product = map.get(key); System.out.println(key + " " + product); &#125; return NONE; &#125; &#125; CRM 保存客户案例实现思路 点击左侧的菜单项。 页面跳转到添加页面。 输入数据，点击提交，将数据到后台。 web 层接收封装数据传递给 service 层，service 层调用 dao 层的方法，将数据保存到数据库中。 最后页面到客户列表显示页面。 代码实现JSP 页面代码123&lt;TR&gt; &lt;TD class=menuSmall&gt;&lt;A class=style2 href="$&#123; pageContext.request.contextPath &#125;/customer_saveUI.action" target=main&gt;－ 新增客户&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt; struts2.xml 配置12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 配置Struts2的常量 --&gt; &lt;constant name="struts.action.extension" value="action"/&gt; &lt;package name="crm" extends="struts-default" namespace="/"&gt; &lt;action name="customer_*" class="com.test.web.action.CustomerAction" method="&#123;1&#125;"&gt; &lt;result name="findSuccess"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;result name="saveUI"&gt;/jsp/customer/add.jsp&lt;/result&gt; &lt;result name="saveSuccess" type="redirectAction"&gt;customer_find.action&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; Action 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.test.web.action;import java.util.List;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;import com.test.domain.Customer;import com.test.service.CustomerService;import com.test.service.impl.CustomerServiceImpl;public class CustomerAction extends ActionSupport implements ModelDriven&lt;Customer&gt; &#123; // 使用 模型驱动的方式需要提供对象的实例 private Customer customer = new Customer(); // 提供模型驱动需要的方法 @Override public Customer getModel() &#123; return customer; &#125; /** * 保存客户的方法 */ public String save() &#123; // 接收数据 // 封装数据 // 使用模型驱动的方式接收数据以及封装数据 // 调用 service 层 CustomerService customerService = new CustomerServiceImpl(); customerService.save(customer); // 页面跳转 return "saveSuccess"; &#125; /** * 跳转到添加页面的方法 */ public String saveUI() &#123; return "saveUI"; &#125; /** * 查询客户列表的方法 * @return */ public String find() &#123; CustomerService customerService = new CustomerServiceImpl(); List&lt;Customer&gt; list = customerService.find(); // 获得 request 对象，将获取到的数据放到域中返回到页面上 ServletActionContext.getRequest().setAttribute("list", list); return "findSuccess"; &#125;&#125; service 层1234567891011121314151617181920212223242526package com.test.service.impl;import java.util.List;import com.test.dao.CustomerDao;import com.test.dao.impl.CustomerDaoImpl;import com.test.domain.Customer;import com.test.service.CustomerService;public class CustomerServiceImpl implements CustomerService &#123; @Override // 保存客户 public void save(Customer customer) &#123; CustomerDao customerDao = new CustomerDaoImpl(); customerDao.save(customer); &#125; @Override // 查询客户列表 public List&lt;Customer&gt; find() &#123; CustomerDao customerDao = new CustomerDaoImpl(); return customerDao.find(); &#125;&#125; dao 层1234567891011121314151617181920212223242526272829303132333435363738package com.test.dao.impl;import java.util.List;import org.hibernate.Session;import org.hibernate.Transaction;import com.test.dao.CustomerDao;import com.test.domain.Customer;import com.test.utils.HibernateUtils;public class CustomerDaoImpl implements CustomerDao &#123; @Override // 保存客户 public void save(Customer customer) &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); session.save(customer); tx.commit(); &#125; @Override // 查找客户列表 public List&lt;Customer&gt; find() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询所有客户 List&lt;Customer&gt; list = session.createQuery("from Customer").list(); tx.commit(); return list; &#125; &#125; 实现效果 学习目标能够学会使用 Struts2 接收数据和封装数据。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2（一）]]></title>
    <url>%2Fstruts2_01%2F</url>
    <content type="text"><![CDATA[Struts 的概述什么是 Struts2Struts 是一个基于 MVC 设计模式的 Web 层 框架。它本质上相当于一个 Servlet，在 MVC 设计模式中，Struts2 作为控制器来建立模型与视图的数据交互。 常用的 web 层框架Struts2、Struts1、WebWork、SpringMVC Web 层框架基于前端控制器模型设计 Struts2 的入门下载 Struts2 的开发环境并揭解压http://struts.apache.org/ Struts2 的目录结构 apps ：Struts2 提供的应用 docs ：Struts2 的开发文档和 API lib ：Struts2 框架的开发的 jar 包 src ：Struts2 的源码 创建动态 web 项目，引入 jar 包 创建一个 jsp 页面12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Struts2 的入门&lt;/h1&gt;&lt;h3&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/hello.action"&gt;Struts2 的入门&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 编写 Action 类12345678910111213141516171819/** * Struts2 的入门的 Action * @author Tong * */public class HelloAction &#123; /** * 提供一个方法： * * 方法签名是固定的，公有访问、返回值是 String 类型、方法名是 execute() 且方法没有参数 * * 因为底层需要使用反射调用 * @return */ public String execute() &#123; System.out.println("HelloAction 执行了..."); return null; &#125; &#125; 对 Action 进行配置12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 配置 struts2 的常量 --&gt; &lt;constant name="struts.action.extension" value="action" /&gt; &lt;!-- Struts2 为了管理 Action的配置，通过包来管理 --&gt; &lt;!-- 配置 Struts2 的包 --&gt; &lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 配置 Action --&gt; &lt;action name="hello" class="com.test.struts.demo1.HelloAction"&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 配置前端控制器（过滤器）12345678910&lt;!-- 配置 Struts2 的核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 改写 Action 中的方法的返回值1234public String execute() &#123; System.out.println("HelloAction 执行了..."); return "success";&#125; 改写 struts.xml1234567&lt;!-- 配置 Struts2 的包 --&gt;&lt;package name="demo1" extends="struts-default" namespace="/"&gt; &lt;!-- 配置 Action --&gt; &lt;action name="hello" class="com.test.struts.demo1.HelloAction"&gt; &lt;result name="success"&gt;/demo1/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 编写 success.jsp 页面123456789101112&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;页面跳转成功！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Struts2 的执行流程当用户访问某一个 Action 时，先经过核心过滤器。在核心过滤器中会执行一组拦截器（这组拦截器实现了一部分的功能），通过 struts.xml 配置文件找到 Action 对象，执行目标 Action，根据 Action 中方法的返回值，从 struts.xml 文件中找到 result 标签完成页面跳转。 Struts2 的配置文件的加载顺序default.properties struts-default.xml struts-plugin.xml struts.xml struts.properties web.xml 注意：后配置的常量的值会覆盖先配置的常量的值。 Action 的配置package 相关配置 package 标签称为包，这个包与 Java 中的包概念不一样，它是为了更好的管理 action 的配置的。 package 标签的属性 name ：包的名称，在一个项目中不重名即可。 extends ：继承哪个包，通常继承 struts-default 这个包。 namespace ：名称空间，与 &lt;action&gt; 标签中的 name 共同决定 Action 的访问路径。 名称空间的三种写法 带名称的名称空间 ：namespace=&quot;/aaa&quot; 根名称空间 ：namespace=&quot;/&quot; 默认名称空间 ：namespace=&quot;&quot; abstract ：抽象的，默认值为 true，意思就是可以被其他包继承。 action 的相关配置action 标签的属性 name ：与 namespace 共同决定 Action 的访问路径 class ：Action 类的全路径 method ：执行 Action 中的方法的名称，默认方法为 execute converter ：用于自定义设置类型转换器 常量的配置 在 Struts2 框架中提供了很多了常量，在 default-properties 配置文件中。 修改常量的值有三种方式 在 struts.xml 中修改 12&lt;!-- 配置 struts2 的常量 --&gt;&lt;constant name="struts.action.extension" value="action" /&gt; 在 struts.properties 中修改 1struts.action.extension=action 在 web.xml 中修改 12345&lt;!-- 修改常量 --&gt;&lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;action&lt;/param-value&gt;&lt;/init-param&gt; 分模块开发的配置使用 include 标签配置，在主配置文件 struts.xml 中引入一个子模块的配置文件 12&lt;!-- 引入分模块下的 struts2 配置文件 --&gt;&lt;include file="com/test/struts/demo2/struts_demo2.xml" /&gt; Action 类的访问Action 类的写法Action 类是一个 POJO 的类 POJO 即一个简单的 Java 类 12345678910111213/** * Action 类的编写方式一：Action 类是一个 POJO 的类，即一个简单的 Java 类 * @author Tong * */public class ActionDemo1 &#123; public String execute() &#123; System.out.println("ActionDemo1 执行了..."); return null; &#125; &#125; Action 类实现一个 Action 接口123456789101112131415161718192021222324import java.io.IOException;import com.opensymphony.xwork2.Action;/** * Action 类的编写方式二：实现 Action接口 * * Action 接口中包含五个逻辑视图常量 * * SUCCESS : 成功 * * ERROR : 失败 * * LOGIN : 登录出错页面跳转 * * INPUT : 表单校验出错跳转 * * NONE : 不跳转 * @author Tong * */public class ActionDemo2 implements Action &#123; @Override public String execute() throws Exception &#123; System.out.println("ActionDemo2 执行了..."); return NONE; &#125;&#125; Action 类继承一个 ActionSupport 类（推荐）1234567891011121314151617import com.opensymphony.xwork2.ActionSupport;/** * Action 类的编写方式三：Action 类继承 ActionSupport 类 * 推荐使用这种方式编写 Action 类，ActionSupport 里封装了很多功能 * @author Tong * */public class ActionDemo3 extends ActionSupport &#123; @Override public String execute() throws Exception &#123; System.out.println("ActionDemo3 执行了..."); return NONE; &#125; &#125; Action 的访问通过 &lt;action&gt; 标签中 method 的设置action 配置 123456&lt;!-- 配置 Action --&gt;&lt;!-- 使用 method 方式访问 Action 的配置 --&gt;&lt;action name="userFind" class="com.test.struts.demo3.UserAction" method="find" /&gt;&lt;action name="userUpdate" class="com.test.struts.demo3.UserAction" method="update" /&gt;&lt;action name="userDelete" class="com.test.struts.demo3.UserAction" method="delete" /&gt;&lt;action name="userSave" class="com.test.struts.demo3.UserAction" method="save" /&gt; 页面访问 12345&lt;h3&gt;通过 method 的方式访问 Action&lt;/h3&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/userFind.action"&gt;查询用户&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/userUpdate.action"&gt;修改用户&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/userDelete.action"&gt;删除用户&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/userSave.action"&gt;保存用户&lt;/a&gt;&lt;/br&gt; 通过通配符的方式进行配置（推荐）action 配置 12&lt;!-- 通过通配符的方式访问 Action 的配置 --&gt;&lt;action name="product_*" class="com.test.struts.demo3.ProductAction" method="&#123;1&#125;" /&gt; 编写访问路径 12345&lt;h3&gt;通过 通配符 的方式访问 Action&lt;/h3&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/product_find.action"&gt;查询商品&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/product_update.action"&gt;修改商品&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/product_delete.action"&gt;删除商品&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/product_save.action"&gt;保存商品&lt;/a&gt;&lt;/br&gt; 通过动态方法访问的方式在使用动态方法访问之前，需要先通过常量开启动态访问 12&lt;!-- 开启动态方式访问 --&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; action 配置 12&lt;!-- 通过动态方法访问 的方式去访问 Action 的配置 --&gt;&lt;action name="customer" class="com.test.struts.demo3.CustomerAction"&gt;&lt;/action&gt; 编写访问路径 12345&lt;h3&gt;通过动态方法访问的方式去访问 Action&lt;/h3&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/customer!find.action"&gt;查询客户&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/customer!update.action"&gt;修改客户&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/customer!delete.action"&gt;删除客户&lt;/a&gt;&lt;/br&gt;&lt;a href="$&#123; pageContext.request.contextPath &#125;/customer!save.action"&gt;保存客户&lt;/a&gt;&lt;/br&gt; CRM 客户列表显示案例搭建开发环境创建 web 项目，引入 jar 包引入 Struts2、Hibernate、jstl 的 jar 包 引入配置文件核心配置、映射文件、日志文件 创建数据库和表12345678910CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建三层架构的包结构web、service、dao、domain、utils 包 引入相应的页面案例的代码实现确定操作位置，修改请求路径123&lt;TR&gt; &lt;TD class=menuSmall&gt;&lt;A class=style2 href="/struts2_crm/customer_find.action" target=main&gt;－ 客户列表&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt; 编写 Action、Service、Dao 中的接口和实现类Action 类 123456789101112131415161718192021222324import java.util.List;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;import com.test.domain.Customer;import com.test.service.CustomerService;import com.test.service.impl.CustomerServiceImpl;/** * CustomerAction 类 */public class CustomerAction extends ActionSupport &#123; public String find() &#123; CustomerService customerService = new CustomerServiceImpl(); List&lt;Customer&gt; list = customerService.find(); // 获得 request 对象，将获取到的数据放到域中返回到页面上 ServletActionContext.getRequest().setAttribute("list", list); return "findSuccess"; &#125; &#125; Service 接口实现类 123456789101112131415161718import java.util.List;import com.test.dao.CustomerDao;import com.test.dao.impl.CustomerDaoImpl;import com.test.domain.Customer;import com.test.service.CustomerService;/** * CustomerService 接口的实现类 */public class CustomerServiceImpl implements CustomerService &#123; @Override public List&lt;Customer&gt; find() &#123; CustomerDao customerDao = new CustomerDaoImpl(); return customerDao.find(); &#125;&#125; Dao 接口实现类 1234567891011121314151617181920212223242526import java.util.List;import org.hibernate.Session;import org.hibernate.Transaction;import com.test.dao.CustomerDao;import com.test.domain.Customer;import com.test.utils.HibernateUtils;/** * CustomerDao 接口的实现类 */public class CustomerDaoImpl implements CustomerDao &#123; @Override public List&lt;Customer&gt; find() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询所有客户 List&lt;Customer&gt; list = session.createQuery("from Customer").list(); tx.commit(); return list; &#125; &#125; 配置 Action1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 配置Struts2的常量 --&gt; &lt;constant name="struts.action.extension" value="action"/&gt; &lt;package name="crm" extends="struts-default" namespace="/"&gt; &lt;action name="customer_*" class="com.test.web.action.CustomerAction" method="&#123;1&#125;"&gt; &lt;result name="findSuccess"&gt;/jsp/customer/list.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 编写页面使用 jstl 获取 request 域中的数据并显示到页面上 12345678910111213141516171819202122232425262728&lt;TBODY&gt; &lt;TR style="FONT-WEIGHT: bold; FONT-STYLE: normal; BACKGROUND-COLOR: #eeeeee; TEXT-DECORATION: none"&gt; &lt;TD&gt;客户名称&lt;/TD&gt; &lt;TD&gt;客户级别&lt;/TD&gt; &lt;TD&gt;客户来源&lt;/TD&gt; &lt;TD&gt;客户所属职业&lt;/TD&gt; &lt;TD&gt;电话&lt;/TD&gt; &lt;TD&gt;手机&lt;/TD&gt; &lt;TD&gt;操作&lt;/TD&gt; &lt;/TR&gt; &lt;c:forEach items="$&#123;list &#125;" var="customer"&gt; &lt;TR style="FONT-WEIGHT: normal; FONT-STYLE: normal; BACKGROUND-COLOR: white; TEXT-DECORATION: none"&gt; &lt;TD&gt;$&#123;customer.cust_name &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.cust_level &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.cust_source &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.cust_industry &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.cust_phone &#125;&lt;/TD&gt; &lt;TD&gt;$&#123;customer.cust_mobile &#125;&lt;/TD&gt; &lt;TD&gt; &lt;a href="$&#123;pageContext.request.contextPath &#125;/customerServlet?method=edit&amp;custId=$&#123;customer.cust_id&#125;"&gt;修改&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href="$&#123;pageContext.request.contextPath &#125;/customerServlet?method=delete&amp;custId=$&#123;customer.cust_id&#125;"&gt;删除&lt;/a&gt; &lt;/TD&gt; &lt;/TR&gt; &lt;/c:forEach&gt;&lt;/TBODY&gt; 实现效果]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate (四)]]></title>
    <url>%2Fhibernate04%2F</url>
    <content type="text"><![CDATA[Hibernate 的查询方式 Hibernate 共提供了五种查询方式。 OID 查询使用 get 方法Customer customer = session.get(Customer.class, 1l); 使用 load 方法Customer customer = session.load(Customer.class, 1l); 对象导航查询对象导航查询是 Hibernate 根据一个已经查询到的对象获得其关联的对象的一种查询方式。 1234567//通过客户获取联系人Customer customer = session.get(Customer.class, 1l); // 查询 1 号客户Set&lt;LinkMan&gt; linkMans = customer.getLinkMans(); // 获得 1 号客户的所有的联系人的集合//通过联系人获取客户LinkMan linkMan = session.get(LinkMan.class, 1l); // 查询 1 号联系人Customer customer = linkMan.getCustomer(); // 查询 1 号联系人所属的客户 HQL 检索HQL（Hibernate Query Language）查询，是一种面向对象的查询语言，语法类似于 SQL，通过 session.createQuery() 接收一个 HQL 语句来进行查询。 HQL 的简单查询123456789101112131415161718192021@Test/** * HQL 的简单查询 */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // HQL 的简单查询 Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); // SQL 中支持 * 号的写法，但 HQL 中不支持 /*Query query = session.createQuery("select * from Customer"); List&lt;Customer&gt; list = query.list(); // 报错 */ for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; HQL 的别名查询1234567891011121314151617181920@Test/** * HQL 的别名查询 */public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Query query = session.createQuery("from Customer c"); List&lt;Customer&gt; list = query.list(); /*Query query = session.createQuery("select c from Customer c"); List&lt;Customer&gt; list = query.list();*/ for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; HQL 的排序查询12345678910111213141516171819202122@Test/** * HQL 的排序查询 */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 排序查询 // 默认是升序的：order by ~ asc /*Query query = session.createQuery("from Customer order by cust_id"); List&lt;Customer&gt; list = query.list();*/ // 设置降序排序：order by ~ desc Query query = session.createQuery("from Customer order by cust_id desc"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; HQL 的条件查询1234567891011121314151617181920212223242526272829303132333435@Test/*** HQL 的条件查询 */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 条件查询，可分为两种 // 1. 按位置绑定 // 一个条件的查询 /* Query query = session.createQuery("from Customer where cust_name = ?"); // 设置条件 query.setParameter(0, "张三");*/ // 多个条件的查询 /*Query query = session.createQuery("from Customer where cust_name like ? and cust_source = ?"); // 设置条件 query.setParameter(0, "李%"); query.setParameter(1, "朋友推荐");*/ // 2. 按名称绑定 Query query = session.createQuery("from Customer where cust_name like :aaa and cust_source = :bbb"); query.setParameter("aaa", "李%"); query.setParameter("bbb", "朋友推荐"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer.toString()); &#125; tx.commit();&#125; HQL 的投影查询12345678910111213141516171819202122232425262728293031323334@Test/** * HQL 的投影查询 */public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 投影查询 // 单个属性的查询 /*Query query = session.createQuery("select c.cust_name from Customer c"); List&lt;Object&gt; list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; */ // 多个属性的查询 /*Query query = session.createQuery("select c.cust_name,c.cust_source from Customer c"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125;*/ // 多个属性的查询，并将其每一条查询结果封装到一个对象中 Query query = session.createQuery("select new Customer(cust_name, cust_source) from Customer"); List&lt;Object&gt; list = query.list(); for (Object object : list) &#123; System.out.println(object); &#125; tx.commit();&#125; HQL 的分页查询1234567891011121314151617181920212223@Test/** * 分页查询 */public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 分页查询 Query query = session.createQuery("from LinkMan"); // 设置分页的参数 // 设置从第几条开始 query.setFirstResult(0); // 设置每页显示几条 query.setMaxResults(10); List&lt;LinkMan&gt; list = query.list(); for (LinkMan linkMan : list) &#123; System.out.println(linkMan); &#125; tx.commit();&#125; HQL 的分组统计查询12345678910111213141516171819@Test/** * HQL 聚合函数使用以及分组统计查询 */public void demo8() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 聚合函数的使用 Object object = session.createQuery("select count(*) from Customer").uniqueResult(); System.out.println(object); // 分组统计查询 List&lt;Object[]&gt; list = session.createQuery("select cust_name,count(*) from Customer group by cust_source having count(*) &gt;= 2").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit();&#125; HQL 的多表查询1234567891011121314151617181920212223@Test/** * HQL 的多表查询 */public void demo9() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 内连接 /*List&lt;Object[]&gt; list = session.createQuery("from Customer c inner join c.linkMans").list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125;*/ // 迫切内连接 fetch 的作用就是通知 Hibernate 将另一个对象的数据封装到该对象中 List&lt;Customer&gt; list = session.createQuery("select distinct c from Customer c inner join fetch c.linkMans").list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; QBC 检索QBC（Query By Criteria）查询，是一种更加面向对象化的查询方式。 QBC 的简单查询123456789101112131415161718@Test/** * 简单查询 */public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询 Criteria criteria = session.createCriteria(Customer.class); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; QBC 的排序查询1234567891011121314151617181920212223@Test/** * 排序查询 */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 排序查询 Criteria criteria = session.createCriteria(Customer.class); // 设置排序 // asc 为升序，按照 cust_id 升序排序 //criteria.addOrder(Order.asc("cust_id")); // desc 为降序，按照 cust_id 降序排序 criteria.addOrder(Order.desc("cust_id")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; QBC 的分页查询1234567891011121314151617181920212223@Test/** * 分页查询 */public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 分页查询 Criteria criteria = session.createCriteria(LinkMan.class); // 设置分页参数 // 从第几条数据开始 criteria.setFirstResult(0); // 每页显示几条数据 criteria.setMaxResults(10); List&lt;LinkMan&gt; list = criteria.list(); for (LinkMan linkMan : list) &#123; System.out.println(linkMan); &#125; tx.commit();&#125; QBC 的条件查询12345678910111213141516171819202122232425262728293031323334@Test/** * 条件查询 */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 条件查询 Criteria criteria = session.createCriteria(Customer.class); // 设置条件 /** * = eq * &gt; gt * &gt;= ge * &lt; lt * &lt;= le * &lt;&gt; ne * like 模糊匹配 * in 包含 * and 以及 * or 或者 */ // 查询来源是：广告、姓：张 的 记录 criteria.add(Restrictions.eq("cust_source", "广告")); criteria.add(Restrictions.like("cust_name", "张%")); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; QBC 的统计查询123456789101112131415161718192021@Test/** * 统计查询 */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 统计查询 Criteria criteria = session.createCriteria(Customer.class); /** * add : 普通条件 * addOrder : 排序条件 * setProjection : 聚合函数条件 和 group by having 条件 */ Long num = (Long) criteria.setProjection(Projections.rowCount()).uniqueResult(); System.out.println(num); tx.commit();&#125; QBC 的离线条件查询12345678910111213141516171819202122@Test/** * 离线条件查询 */public void demo6() &#123; // web 层 需要做的 DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Customer.class); detachedCriteria.add(Restrictions.like("cust_name", "李%")); Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 离线查询对象与 Session 绑定 Criteria criteria = detachedCriteria.getExecutableCriteria(session); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; Hibernate 的抓取策略（优化）延迟加载什么是延迟加载延迟加载即 lazy（懒加载）。执行到该行代码时，不会马上发送 SQL 语句去查询，而是在真正的使用这个对象的时候才会去发送 SQL 语句去查询。 延迟加载的分类类级别的延迟加载类级别的延迟加载指的是通过 load 方法查询某个对象的时候，是否采用延迟。它是通过在 &lt;class&gt; 标签上的 lazy 进行配置，如果要让 lazy 失效，可以采用以下几种方式： 将 lazy 设置为 false 将持久化类使用 final 修改，不可继承 使用 Hibernate.initialize() 方法 关联级别的延迟加载关联级别的延迟加载指的是在查询到某个对象的时候，同时查询其关联对象的时候，是否采用延迟加载。 抓取策略 抓取策略往往会和关联级别的延迟加载一起使用来优化语句。 抓取策略的概述通过一个对象抓取其关联对象时需要发送 SQL 语句，如何发送 SQL 语句，以什么样的格式发送，是可以通过策略去配置的，即可以通过 &lt;set&gt; 标签和 &lt;many-to-one&gt; 标签上的 fetch 和 lazy 属性进行设置。 &lt;set&gt; 标签上的 fetch 和 lazy 的配置 fetch：即抓取策略，控制发送 SQL 语句的格式 取值： select ：默认值，发送普通的 select 语句查询关联对象 join ：发送一条迫切左外连接查询关联对象 subselect ：发送一条子查询查询其关联对象 lazy：即延迟加载，控制查询关联对象时是否采用延迟 取值： true ：默认值，采用延迟加载 false ：不采用延迟加载 extra ：采用延迟加载，比 true 更懒 &lt;many-to-one&gt; 标签上的 fetch 和 lazy 的配置 fetch：即抓取策略，控制发送 SQL 语句的格式 取值： select ：默认值，发送普通的 SQL 语句查询关联对象 join：发送一条迫切左外连接 SQL 语句 lazy：即延迟加载，控制查询关联对象时是否采用延迟 取值： proxy ：默认值，proxy 具体的取值取决于关联对方的 &lt;class&gt; 标签上的 lazy 的取值 false：不采用延迟加载 no-proxy：该取值不用 注意在实际开发过程中，一般都采用默认值，如果有特殊需要，可能会用到配置 join。但是面试会问抓取策略的优化。 批量抓取抓取一批关联对象，默认只会抓取一个，可以通过在&lt;set&gt;标签和&lt;class&gt;标签上通过batch-size属性来设置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.test.hibernate.demo2;import java.util.List;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.test.hibernate.domain.Customer;import com.test.hibernate.domain.LinkMan;import com.test.hibernate.utils.HibernateUtils;/** * 批量抓取的测试类 * @author Tong * */public class HibernateDemo3 &#123; @Test /** * 获取客户的时候，批量抓取联系人 * 需要在客户的配置文件中的 &lt;set&gt; 上配置 batch-size 属性，默认值为 1，即每次抓取一个 */ public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询所有客户 List&lt;Customer&gt; list = session.createQuery("from Customer").list(); for (Customer customer : list) &#123; System.out.println(customer.getCust_name()); // 查看每个客户的所有联系人 for (LinkMan linkMan : customer.getLinkMans()) &#123; System.out.println(linkMan.getLkm_name()); &#125; &#125; tx.commit(); &#125; @Test /** * 获取联系人的时候，批量抓取客户 * 需要在客户的配置文件中的 &lt;class&gt; 上配置 batch-size 属性，默认值为 1，即每次抓取一个 */ public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询所有的联系人 List&lt;LinkMan&gt; list = session.createQuery("from LinkMan").list(); for (LinkMan linkMan : list) &#123; System.out.println(linkMan.getLkm_name()); System.out.println(linkMan.getCustomer().getCust_name()); &#125; tx.commit(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate (三)]]></title>
    <url>%2Fhibernate03%2F</url>
    <content type="text"><![CDATA[数据库表与表之间的关系一对多的关系举例说明一个部门可以有多名员工，但一个员工只能隶属于一个部门。 建表原则在多的一方创建外键指向一的一方的主键。 多对多关系举例说明一个学生可以选修多门课程，同时一门课程也可以被多名学生选修。 建表原则创建一个中间表，中间表至少有两个字段分别作为外键指向多对多双方的主键。 一对一关系举例说明一个人只能对应一个身份证号，一个身份证号也只能归属于一个人。 建表原则 唯一外键对应。假设把一对一关系看成是一对多关系，在多的一方建立唯一外键指向一的一方的主键。 主键对应。两个表的主键相同。 Hibernate 的一对多关系的关联映射Hibernate 的一对多的关系的配置创建一个项目引入响应的 jar 包和配置文件创建表客户表12345678910CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 联系人123456789101112131415CREATE TABLE `cst_linkman` ( `lkm_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)', `lkm_name` varchar(16) DEFAULT NULL COMMENT '联系人姓名', `lkm_cust_id` bigint(32) DEFAULT NULL COMMENT '客户id', `lkm_gender` char(1) DEFAULT NULL COMMENT '联系人性别', `lkm_phone` varchar(16) DEFAULT NULL COMMENT '联系人办公电话', `lkm_mobile` varchar(16) DEFAULT NULL COMMENT '联系人手机', `lkm_email` varchar(64) DEFAULT NULL COMMENT '联系人邮箱', `lkm_qq` varchar(16) DEFAULT NULL COMMENT '联系人qq', `lkm_position` varchar(16) DEFAULT NULL COMMENT '联系人职位', `lkm_memo` varchar(512) DEFAULT NULL COMMENT '联系人备注', PRIMARY KEY (`lkm_id`), KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`), CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建与数据库表对应的实体类客户实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.test.hibernate.domain;import java.util.HashSet;import java.util.Set;/** * 客户类 * @author Tong * */public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; // 通过 ORM 的方式表示：一个客户可以有多个联系人 // 一的一方创建多的一方的 Set 集合，Hibernate 中默认使用的是 Set 集合 private Set&lt;LinkMan&gt; linkMans = new HashSet&lt;LinkMan&gt;(); public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; public Set&lt;LinkMan&gt; getLinkMans() &#123; return linkMans; &#125; public void setLinkMans(Set&lt;LinkMan&gt; linkMans) &#123; this.linkMans = linkMans; &#125; &#125; 联系人实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.test.hibernate.domain;/** * 联系人类 * @author Tong */public class LinkMan &#123; private Long lkm_id; private String lkm_name; private String lkm_gender; private String lkm_phone; private String lkm_mobile; private String lkm_email; private String lkm_qq; private String lkm_memo; // 通过 ORM 的方式表示：一个联系人只能属于一个客户 // 多的一方创建一的一方的对象 private Customer customer; public Long getLkm_id() &#123; return lkm_id; &#125; public void setLkm_id(Long lkm_id) &#123; this.lkm_id = lkm_id; &#125; public String getLkm_name() &#123; return lkm_name; &#125; public void setLkm_name(String lkm_name) &#123; this.lkm_name = lkm_name; &#125; public String getLkm_gender() &#123; return lkm_gender; &#125; public void setLkm_gender(String lkm_gender) &#123; this.lkm_gender = lkm_gender; &#125; public String getLkm_phone() &#123; return lkm_phone; &#125; public void setLkm_phone(String lkm_phone) &#123; this.lkm_phone = lkm_phone; &#125; public String getLkm_mobile() &#123; return lkm_mobile; &#125; public void setLkm_mobile(String lkm_mobile) &#123; this.lkm_mobile = lkm_mobile; &#125; public String getLkm_email() &#123; return lkm_email; &#125; public void setLkm_email(String lkm_email) &#123; this.lkm_email = lkm_email; &#125; public String getLkm_qq() &#123; return lkm_qq; &#125; public void setLkm_qq(String lkm_qq) &#123; this.lkm_qq = lkm_qq; &#125; public String getLkm_memo() &#123; return lkm_memo; &#125; public void setLkm_memo(String lkm_memo) &#123; this.lkm_memo = lkm_memo; &#125; public Customer getCustomer() &#123; return customer; &#125; public void setCustomer(Customer customer) &#123; this.customer = customer; &#125; &#125; 创建映射文件（重点）多的一方的映射的创建12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立实体类与数据库表的映射 --&gt; &lt;class name="com.test.hibernate.domain.Customer" table="cst_customer"&gt; &lt;!-- 建立 OID 与数据库表中主键的映射 --&gt; &lt;id name="cust_id" column="cust_id"&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;!-- 建立类中其他属性与数据库表字段的映射 --&gt; &lt;property name="cust_name" /&gt; &lt;property name="cust_source" /&gt; &lt;property name="cust_industry" /&gt; &lt;property name="cust_level" /&gt; &lt;property name="cust_phone" /&gt; &lt;property name="cust_mobile" /&gt; &lt;!-- 配置一对多的关系映射：放置的是多的一方的对象的 set 集合 --&gt; &lt;!-- set 标签： * name : 多的一方的对象集合名称 * inverse : 是否放弃对外键的管理，默认为 false，即不放弃 --&gt; &lt;set name="linkMans" cascade="save-update,delete" inverse="true"&gt; &lt;!-- key 标签： * column : 多的一方的外键名称 --&gt; &lt;key column="lkm_cust_id" /&gt; &lt;!-- one-to-many: * class : 多的一方的类的全路径 --&gt; &lt;one-to-many class="com.test.hibernate.domain.LinkMan"/&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 一的一方的映射的创建123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立实体类与数据库之间的映射 --&gt; &lt;class name="com.test.hibernate.domain.Role" table="sys_role"&gt; &lt;!-- 建立 OID 与数据库表主键的映射 --&gt; &lt;id name="role_id" column="role_id"&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表中其他字段的映射 --&gt; &lt;property name="role_name" column="role_name" /&gt; &lt;property name="role_memo" column="role_memo" /&gt; &lt;!-- 建立角色与用户的多对多关系 --&gt; &lt;!-- set 标签： * name : 对方在本类中的集合的名称 * table : 中间表的名称 --&gt; &lt;set name="users" table="sys_user_role" cascade="save-update,delete" inverse="true" &gt; &lt;!-- key 标签： * column : 当前对象对应中间表中外键的名称 --&gt; &lt;key column="role_id" /&gt; &lt;!-- many-to-many 标签 * class : 对方类的全路径 * column : 对方对象对应中间表的外键名称 --&gt; &lt;many-to-many class="com.test.hibernate.domain.User" column="user_id"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 创建核心配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 1. 连接数据库的基本参数 --&gt; &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///hibernate_day03&lt;/property&gt; &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt; &lt;property name="hibernate.connection.password"&gt;1&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 2. 可选配置 --&gt; &lt;!-- 打印 SQL 语句 --&gt; &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt; &lt;!-- 格式化 SQL 语句 --&gt; &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt; &lt;!-- 自动建表 --&gt; &lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;property name="connection.provider_class"&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接的最少数目 --&gt; &lt;property name="c3p0.min_size"&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目 --&gt; &lt;property name="c3p0.max_size"&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间,以秒为单位, 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt; &lt;property name="c3p0.timeout"&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位 --&gt; &lt;property name="c3p0.idle_test_period"&gt;3000&lt;/property&gt; &lt;!-- 设置事务的隔离级别 --&gt; &lt;!-- 4 为 mysql 的默认隔离级别 --&gt; &lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; &lt;!-- 配置 Session 绑定当前线程--&gt; &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; &lt;!-- 3. 引入映射文件 --&gt; &lt;mapping resource="com/test/hibernate/domain/Customer.hbm.xml"/&gt; &lt;mapping resource="com/test/hibernate/domain/LinkMan.hbm.xml"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 编写测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.test.hibernate.demo1;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.test.hibernate.domain.Customer;import com.test.hibernate.domain.LinkMan;import com.test.hibernate.utils.HibernateUtils;/** * 一对多关系映射的测试类 * @author Tong * */public class HibernateDemo1 &#123; @Test // 保存 2 个客户 3 个联系，并且建立好关系存到数据库中 public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建两个客户 Customer customer1 = new Customer(); customer1.setCust_name("张三"); Customer customer2 = new Customer(); customer2.setCust_name("李四"); // 创建三个联系人 LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name("王五"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name("赵六"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name("田七"); // 建立关系 // 一个联系人对应一个客户 linkMan1.setCustomer(customer1); linkMan2.setCustomer(customer1); linkMan3.setCustomer(customer2); // 一个客户可以有多个联系人 customer1.getLinkMans().add(linkMan1); customer1.getLinkMans().add(linkMan2); customer2.getLinkMans().add(linkMan3); // 保存数据 // 保存联系人 session.save(linkMan1); session.save(linkMan2); session.save(linkMan3); // 保存客户 session.save(customer1); session.save(customer2); tx.commit(); &#125; &#125; Hibernate 的一对多的相关操作一对多关系只保存一边是否可以成功只保存一边是不可以的，会报一个瞬时态对象异常，因为持久态关联了一个瞬时态的对象。 1234567891011121314151617181920@Test// 测试一对多关系只保存一边是否可以public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("张三"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("李四"); linkMan.setCustomer(customer); customer.getLinkMans().add(linkMan); // 只保存客户，不可以，报一个瞬时态对象异常，因为持久态对象关联了一个瞬时态对象 session.save(customer); tx.commit();&#125; 一对多的级联操作 级联指的是在操作一个对象的时候会同时操作其关联的对象。 级联保存或更新保存客户级联保存联系人要完成级联操作首先需要在客户的映射文件中的 set 集合上进行级联配置 &lt;set name=&quot;linkMans&quot; cascade=&quot;save-update,delete&quot; ... 编写测试代码 123456789101112131415161718192021222324@Test/** * 级联保存或更新 * * 保存客户级联联系人，操作的主体是客户，需要在 Customer.hbm.xml 中配置 * * &lt;set name="linkMans" cascade="save-update"&gt; */public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("张三"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("李四"); linkMan.setCustomer(customer); customer.getLinkMans().add(linkMan); // 保存客户级联保存联系人 session.save(customer); tx.commit();&#125; 保存联系人级联保存客户与保存客户级联保存联系人同理，只需进行相应的配置即可，首先在联系人的映射文件中的many-to-one标签上添加一个属性cascade=&quot;save-update&quot; 123456789101112131415161718192021222324@Test/** * 级联保存或更新 * * 保存联系人级联客户，操作的主体是联系人，需要在 LinkMan.hbm.xml 中配置 * * &lt;many-to-one name="customer" cascade="save-update" class="com.test.hibernate.domain.Customer" column="lkm_cust_id" /&gt; */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("王五"); LinkMan linkMan = new LinkMan(); linkMan.setLkm_name("赵六"); linkMan.setCustomer(customer); customer.getLinkMans().add(linkMan); // 保存联系人级联客户 session.save(customer); tx.commit();&#125; 测试对象的导航12345678910111213141516171819202122232425262728293031@Test/** * 测试对象的导航 * * 前提：一对多的双方都设置了 cascade="save-update" */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); Customer customer = new Customer(); customer.setCust_name("张三"); LinkMan linkMan1 = new LinkMan(); linkMan1.setLkm_name("李四"); LinkMan linkMan2 = new LinkMan(); linkMan2.setLkm_name("王五"); LinkMan linkMan3 = new LinkMan(); linkMan3.setLkm_name("赵六"); // 设置关联关系 linkMan1.setCustomer(customer); customer.getLinkMans().add(linkMan2); customer.getLinkMans().add(linkMan3); // 前提双方都设置了级联 session.save(linkMan1); // 会发送 4 条 insert 语句 // session.save(customer); // 会发送 3 条 insert 语句 // session.save(linkMan2); // 会发送 1 条 insert 语句 tx.commit();&#125; 级联删除（基本不用） 删除一边的时候，同时将另一边的数据也一并删除。 如果要使用级联删除，前提是需要在主体方的映射文件中配置一个属性 cascade=&quot;delete&quot;，这样的话，只有主体方的数据被删除，那么相应的与它有关联的客体的数据也会被级联删除。 删除客户级联删除联系人123456789101112131415161718192021@Test/** * 级联删除 * * 删除客户级联删除联系人，操作的主体是客户，需要在 Customer.hbm.xml 中配置 * * &lt;set name="linkMans" cascade="delete"&gt; */public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 先查询再删除 // 默认情况：先将联系人的外键置为 null，然后删除客户 /*Customer customer = session.get(Customer.class, 1l); session.delete(customer);*/ // 级联删除 Customer customer = session.get(Customer.class, 1l); session.delete(customer); tx.commit();&#125; 删除联系人级联删除客户1234567891011121314151617@Test/** * 级联删除 * * 删除联系人级联删除客户（很少用），操作的主体是联系人，需要在 LinkMan.hbm.xml 中配置 * * &lt;set name="customer" cascade="delete"&gt; */public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 先查询再删除 // 级联删除 LinkMan linkMan = session.get(LinkMan.class, 5l); session.delete(linkMan); tx.commit();&#125; 一对多设置了双向关联产生多余 SQL 语句问题123456789101112131415161718192021@Test/** * 原来 2 号联系人属于 1 号客户，现将其改为隶属于 2 号客户 */public void demo8() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询 2 号联系人 LinkMan linkMan = session.get(LinkMan.class, 2l); // 查询 2 号客户 Customer customer = session.get(Customer.class, 2l); // 双向的关联：会发送重复的 SQL 语句，一的一方放弃外键的管理可以解决资源的浪费。 linkMan.setCustomer(customer); customer.getLinkMans().add(linkMan); // 持久化对象可以自动更新数据库 tx.commit();&#125; 分析产生多余 SQL 的原因第 10 行代码和带 12 行代码分别会查询 2 号联系人和 2 号客户，查到之后会将查到的数据放到一级缓存的缓存区和快照区各一份。 那么当执行到第 15 行代码时，联系人 2 要关联客户 2，此时先会将这条数据放到缓存区中，与快照区中的数据进行对比，如果发生改变就会发送 SQL 语句去更新数据库，如果没有发生改变，就不会发送 SQL 也不会更新数据库，那么经过对比后显然数据发生了改变，这时候就会发送一条 SQL 去更新。 当执行到第 16 行代码时，又进行了一次对比，数据不一致，那么就会再发送一条 SQL 语句去更新数据库。 显然如果设置双向关联之后，就会产生多余的 SQL，进行重复的操作。 解决方法即单向维护关系，使得一方主动放弃外键维护权，一般是被动的一方主动放弃外键维护权。在放弃方的 set 集合上配置inverse=&quot;true&quot;属性，即为放弃外键维护权。 区分 cascade 和 inverse1234567891011121314151617181920@Test/** * 区别 cascade 和 inverse */public void demo9() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询 2 号联系人 LinkMan linkMan = session.get(LinkMan.class, 2l); // 查询 2 号客户 Customer customer = session.get(Customer.class, 2l); customer.getLinkMans().add(linkMan); // 条件：在 Customer.hbm.xml 上的 set 中配置 cascade="save-update" inverse="true" session.save(customer); // 客户会插入到数据库中、联系人也会插入到数据库中，但是外键会为 null tx.commit();&#125; Hibernate 的多对多的关联映射Hibernate 的多对多关系的配置创建表用户表12345678CREATE TABLE `sys_user` ( `user_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '用户id', `user_code` varchar(32) NOT NULL COMMENT '用户账号', `user_name` varchar(64) NOT NULL COMMENT '用户名称', `user_password` varchar(32) NOT NULL COMMENT '用户密码', `user_state` char(1) NOT NULL COMMENT '1:正常,0:暂停', PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 角色表123456CREATE TABLE `sys_role` ( `role_id` bigint(32) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) NOT NULL COMMENT '角色名称', `role_memo` varchar(128) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`role_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 中间表12345678CREATE TABLE `sys_user_role` ( `role_id` bigint(32) NOT NULL COMMENT '角色id', `user_id` bigint(32) NOT NULL COMMENT '用户id', PRIMARY KEY (`role_id`,`user_id`), KEY `FK_user_role_user_id` (`user_id`), CONSTRAINT `FK_user_role_role_id` FOREIGN KEY (`role_id`) REFERENCES `sys_role` (`role_id`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `FK_user_role_user_id` FOREIGN KEY (`user_id`) REFERENCES `sys_user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB DEFAULT CHARSET=utf8; 创建实体类用户实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.test.hibernate.domain;import java.util.HashSet;import java.util.Set;/** * 用户实体类 * @author Tong */public class User &#123; private Long user_id; private String user_code; private String user_name; private String user_password; private String user_state; // 多对多关系，放置的是对方的集合 private Set&lt;Role&gt; roles = new HashSet&lt;Role&gt;(); public Long getUser_id() &#123; return user_id; &#125; public void setUser_id(Long user_id) &#123; this.user_id = user_id; &#125; public String getUser_code() &#123; return user_code; &#125; public void setUser_code(String user_code) &#123; this.user_code = user_code; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getUser_password() &#123; return user_password; &#125; public void setUser_password(String user_password) &#123; this.user_password = user_password; &#125; public String getUser_state() &#123; return user_state; &#125; public void setUser_state(String user_state) &#123; this.user_state = user_state; &#125; public Set&lt;Role&gt; getRoles() &#123; return roles; &#125; public void setRoles(Set&lt;Role&gt; roles) &#123; this.roles = roles; &#125; &#125; 角色实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.test.hibernate.domain;import java.util.HashSet;import java.util.Set;/** * 角色实体类 * @author Tong */public class Role &#123; private Long role_id; private String role_name; private String role_memo; // 多对多关系，放置的是对方的集合 private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); public Long getRole_id() &#123; return role_id; &#125; public void setRole_id(Long role_id) &#123; this.role_id = role_id; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_memo() &#123; return role_memo; &#125; public void setRole_memo(String role_memo) &#123; this.role_memo = role_memo; &#125; public Set&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(Set&lt;User&gt; users) &#123; this.users = users; &#125; &#125; 创建映射配置文件用户的映射文件123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 配置实体类与数据库表的映射 --&gt; &lt;class name="com.test.hibernate.domain.User" table="sys_user"&gt; &lt;!-- 建立 OID 与数据库表主键的映射 --&gt; &lt;id name="user_id" column="user_id"&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表其他字段的映射 --&gt; &lt;property name="user_code" column="user_code" /&gt; &lt;property name="user_name" column="user_name" /&gt; &lt;property name="user_password" column="user_password" /&gt; &lt;property name="user_state" column="user_state" /&gt; &lt;!-- 建立用户与角色的多对多关系的映射 --&gt; &lt;!-- set 标签： * name ： 对方集合的属性名称 * table ： 多对多关系需要中间表，放的是中间表的表名 --&gt; &lt;set name="roles" table="sys_user_role" cascade="save-update,delete"&gt; &lt;!-- key 标签： * column ： 当前的对象在中间表中的外键名称 --&gt; &lt;key column="user_id" /&gt; &lt;!-- many-to-many 标签： * class ： 对方类的全路径 * column ： 对方对象在中间表中的外键名称 --&gt; &lt;many-to-many class="com.test.hibernate.domain.Role" column="role_id" &gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 角色的映射文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立实体类与数据库之间的映射 --&gt; &lt;class name="com.test.hibernate.domain.Role" table="sys_role"&gt; &lt;!-- 建立 OID 与数据库表主键的映射 --&gt; &lt;id name="role_id" column="role_id"&gt; &lt;generator class="native" /&gt; &lt;/id&gt; &lt;!-- 建立普通属性与表中其他字段的映射 --&gt; &lt;property name="role_name" column="role_name" /&gt; &lt;property name="role_memo" column="role_memo" /&gt; &lt;!-- 建立角色与用户的多对多关系 --&gt; &lt;!-- set 标签： * name : 对方在本类中的集合的名称 * table : 中间表的名称 --&gt; &lt;set name="users" table="sys_user_role" cascade="save-update,delete" inverse="true" &gt; &lt;!-- key 标签： * column : 当前对象对应中间表中外键的名称 --&gt; &lt;key column="role_id" /&gt; &lt;!-- many-to-many 标签 * class : 对方类的全路径 * column : 对方对象对应中间表的外键名称 --&gt; &lt;many-to-many class="com.test.hibernate.domain.User" column="user_id"&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在核心配置文件中引入两个对象的映射文件123&lt;!-- 3. 引入映射文件 --&gt;&lt;mapping resource="com/test/hibernate/domain/User.hbm.xml"/&gt;&lt;mapping resource="com/test/hibernate/domain/Role.hbm.xml"/&gt; 编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.test.hibernate.demo2;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.test.hibernate.domain.Role;import com.test.hibernate.domain.User;import com.test.hibernate.utils.HibernateUtils;/** * 测试多对多的关系映射 * @author Tong * */public class HibernateDemo2 &#123; @Test // 保存数据，保存 2 个用户，3 个角色，并建立关系 public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建 2 个用户 User user1 = new User(); user1.setUser_name("张三"); User user2 = new User(); user2.setUser_name("李四"); // 创建 3 个角色 Role role1 = new Role(); role1.setRole_name("研发部"); Role role2 = new Role(); role2.setRole_name("市场部"); Role role3 = new Role(); role3.setRole_name("公关部"); // 多对多建立双向关联映射，需要一方主动放弃外键维护权 // ***一般被动方放弃外键维护权 user1.getRoles().add(role1); user1.getRoles().add(role2); user2.getRoles().add(role2); user2.getRoles().add(role3); role1.getUsers().add(user1); role2.getUsers().add(user1); role2.getUsers().add(user2); role3.getUsers().add(user2); // 保存数据 session.save(user1); session.save(user2); session.save(role1); session.save(role2); session.save(role3); tx.commit(); &#125; &#125; Hibernate 的多对多的操作多对多关系只保存一边是否能够成功不可以，必须要一方放弃外键维护权。 1234567891011121314151617181920212223242526@Test/** * 只保存一边是否可以？ * 不可以，会报瞬时态对象异常 */public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建 1 个用户 User user = new User(); user.setUser_name("张三"); // 创建 1 个角色 Role role = new Role(); role.setRole_name("研发部"); // 建立关系 user.getRoles().add(role); role.getUsers().add(user); // 只保存一边，会报异常 // session.save(user); session.save(role); tx.commit();&#125; 多对多的级联保存或更新 要完成级联操作，前提是需要在主动方的 set 集合上配置一个cascade=&quot;save-update&quot;属性。 保存用户级联保存角色1234567891011121314151617181920212223242526@Test/** * 级联保存： * * 保存用户级联保存角色，需要在用户的映射文件中配置 * * 在 User.hbm.xml 中的 set 上配置 cascade="save-update" */public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建 1 个用户 User user = new User(); user.setUser_name("张三"); // 创建 1 个角色 Role role = new Role(); role.setRole_name("研发部"); // 建立关系 user.getRoles().add(role); role.getUsers().add(user); session.save(user); tx.commit();&#125; 保存角色级联保存用户1234567891011121314151617181920212223242526@Test/** * 级联保存： * * 保存角色级联保存用户，需要在角色的映射文件中配置 * * 在 Role.hbm.xml 中的 set 上配置 cascade="save-update" */public void demo4() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 创建 1 个用户 User user = new User(); user.setUser_name("张三"); // 创建 1 个角色 Role role = new Role(); role.setRole_name("研发部"); // 建立关系 user.getRoles().add(role); role.getUsers().add(user); session.save(role); tx.commit();&#125; 多对多的级联删除（基本不用） 同样要完成级联删除操作，需要在主动方的 set 集合上配置一个 cascade=&quot;delete&quot;属性。 删除用户级联删除角色123456789101112131415161718@Test/** * 级联删除： * * 删除用户级联删除角色，需要在用户的映射文件中配置 * * 在 User.hbm.xml 中的 set 上配置 cascade="delete" */public void demo5() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询 1 号客户 User user = session.get(User.class, 1l); // 删除 1 号客户级联删除相应的角色 session.delete(user); tx.commit();&#125; 删除角色级联删除用户123456789101112131415161718@Test/** * 级联删除： * * 删除角色级联删除用户，需要在角色的映射文件中配置 * * 在 Role.hbm.xml 中的 set 上配置 cascade="delete" */public void demo6() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 查询 2 号角色 Role role = session.get(Role.class, 3l); // 删除 3 号角色级联删除相应的客户 session.delete(role); tx.commit();&#125; 多对多的其他操作给用户添加角色123456789101112131415161718@Test/** * 给用户添加角色 */public void demo7() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 给 1 号用户添加 2 号 角色 // 先查询 1 号用户 User user = session.get(User.class, 1l); // 再查询 2 号角色 Role role = session.get(Role.class, 2l); user.getRoles().add(role); tx.commit();&#125; 给用户改选角色123456789101112131415161718192021@Test/** * 给用户改选角色 */public void demo8() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 给 2 号用户的 2 号 角色改选为 3 号角色 // 先查询 2 号用户 User user = session.get(User.class, 2l); // 查询 2 号角色和 3 号角色 Role role2 = session.get(Role.class, 2l); Role role3 = session.get(Role.class, 3l); // 先移除 2 号角色再添加 3 号角色 user.getRoles().remove(role2); user.getRoles().add(role3); tx.commit();&#125; 给用户删除角色12345678910111213141516171819@Test/** * 给用户删除角色 */public void demo9() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 给 2 号用户删除 3 号 角色 // 先查询 2 号用户 User user = session.get(User.class, 2l); // 查询 2 号角色 Role role3 = session.get(Role.class, 3l); // 删除 2 号角色 user.getRoles().remove(role3); tx.commit();&#125; 学习目标能够使用 Hibernate 搭建一对多或多对多的配置环境。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate (二)]]></title>
    <url>%2Fhibernate02%2F</url>
    <content type="text"><![CDATA[Hibernate 持久化类的编写规则什么是持久化类持久化：就是将内存中的数据永久的存储在关系型数据库中。 持久化类：指的是一个 Java 类与数据库表建立了映射关系，那么这么类就称之为持久化类。 持久化类的编写规则 首先编写持久化类需要提供无参的构造方法，在 Java 中默认构造即无参构造。 持久化类的属性需要私有，对私有的属性提供公共的 set 和 get 方法。 持久化类的属性要尽量使用包装类的类型。举个例子，假如使用基本数据类型 int，它默认值是 0，那么如果把这个 0 存到数据库中，就会产生歧义，到底是用户存的 0 呢，还是用户没有设置呢，它的默认值就是 0 呀。如果使用包装类 Integer 的话就可以避免发生这种情况，我们一起来分析一下，它的默认值是 null，如果用户存一个数，数据库中就会显示相应的数值，如果用户没有设置值，那么数据库中就会显示为 null，一目了然，歧义就解决了。 持久化类要有一个唯一标识 OID 与表的主键对应。 持久化类尽量不要使用 final 进行修饰。因为 Hibernate 中有延时加载优化机制，这个机制中会产生代理对象，会继承持久化类产生子类，从而产生代理对象，如果用 final 修饰的话，这个优化机制就失效了。 Hibernate 主键生成策略主键类型自然主键：把具有业务含义的字段作为主键，称为自然主键。 代理主键：把不具备业务含义的字段作为主键，称之为代理主键，通常使用 id 来作为主键。 Hibernate 的主键生成策略 在实际开发中一般是不允许用户手动设置主键的，一般是手动编写程序进行设置，再交给数据库，在 Hibernate 中为了减少程序代码的编写，它提供了很多中的主键生成策略。 increment：hibernate 中提供的自增长机制，适用 short、int、long 类型的主键。线程不安全，建议在单线程中使用。 identity：适用 short、int、long 类型的主键，采用的是数据库底层的自动增长机制。适用于有自动增长机制的数据库，如 MySQL 等。Oracle 是没有自动增长的。 sequence：适用 short、int、long 类型的主键，采用的是序列化的方式，支持 Oracle 等。 uuid：适用于字符串类型的主键。使用 hibernate 中的随机方式生成字符串主键，类似于 Java 给提供的 UUID 对象。 native：根据本地机制进行自动调整，可以在 identity 和 sequence 之间进行自动切换。 assigned：hibernate 放弃对主键的管理，需要手动编写程序或用户自己设置。 foreign：外部主键。 Hibernate 的持久化的三种状态Hibernate 为了更好的管理持久化类，将持久化类分成了三种状态。分别是瞬时态、持久态、脱管态或游离态。 瞬时态此状态对象没有唯一标识 OID，没有被 session 管理，称为是瞬时态对象。 持久态此状态对象有唯一标识 OID，且被 session 管理，称为持久态对象。 脱管态此状态对象有唯一标识 OID，但没有被 session 管理，称为脱管态对象。 如何区分三种状态对象通过一段代码解释 123456789101112@Testpublic void demo1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); Customer customer = new Customer(); // 瞬时态对象，没有唯一标识 OID，没有被 session 管理 customer.setCust_name("李四"); Serializable id = session.save(customer); // 持久态对象，有唯一标识 OID，被 session 管理 transaction.commit(); session.close(); // 脱管态对象，有唯一标识 OID，没有被 session 管理&#125; 三种状态对象的转换 瞬时态对象获得：Customer customer = new Customer()，简单来说就是 new 状态转换： 瞬时态 –&gt; 持久态 调用保存方法save(Object obj)、调用保存或更新方法saveOrUpdate(Object obj) 瞬时态 –&gt; 脱管态 设置 id，customer.setCust_id() 持久态对象获得：可通过查询方法get()、load()获得 状态转换： 持久态 –&gt; 瞬时态 调用删除方法delete() 持久态 –&gt; 脱管态 session 关闭close()、清除所有clear()、清除某一个对象evict(Object obj) 脱管态对象获得：两部曲，先 new 对象，然后设置 id。Customer customer = new Customer(); customer.setCust_id(1l); 状态转换： 脱管态 –&gt; 瞬时态 将该对象的 id 置为 null 即可 脱管态 –&gt; 持久态 update()、saveOrUpdate() 持久态对象的特性持久态对象能够自动更新数据库 123456789101112@Testpublic void demo2() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); // 获得持久化对象，持久化对象可以自动更新数据库 Customer customer = session.get(Customer.class, 1l); customer.setCust_name("哈哈"); // session.update(customer); transaction.commit(); session.close();&#125; 持久态对象之所以有自动更新数据库的特性是依赖于 Hibernate 的一级缓存。 Hibernate 的一级缓存什么是缓存缓存：是一种优化方式，将数据存到内存当中，使用时从缓存中获取，减少直接向永久性数据源的读取次数，提高应用的性能。 Hibernate 的一级缓存 Hibernate 中提供的优化手段：缓存、抓取策略。Hibernate 中提供了两种缓存机制：一级缓存、二级缓存。 Hibernate 的一级缓存，也称为是 Session 级别的缓存，一级缓存的生命周期与 Session 对象一致，其实一级缓存就是由 Session 对象中的一系列 Java 集合构成的。一级缓存是自带的且不可卸载的。 Hibernate 的二级缓存是基于 SessionFactory 级别的缓存，是需要配置的，通常二级缓存使用 Redis 替代较多。 证明一级缓存的存在123456789101112131415161718192021222324@Test// 证明一级缓存的存在public void demo1() &#123; Session session = HibernateUtils.openSession(); Transaction transaction = session.beginTransaction(); /*Customer customer1 = session.get(Customer.class, 1l); // 发送 SQL，从数据库中查询之后放到一级缓存中 System.out.println(customer1); Customer customer2 = session.get(Customer.class, 1l); // 不发送 SQL，直接从一级缓存中取 System.out.println(customer2); System.out.println(customer1 == customer2);*/ Customer customer1 = new Customer(); customer1.setCust_name("张三"); Serializable id = session.save(customer1); System.out.println(id); Customer customer2 = session.get(Customer.class, id); // 不发送 SQL，save() 之后，会将保存的对象放到缓存中 System.out.println(customer2); System.out.println(customer1 == customer2); transaction.commit(); session.close();&#125; Hibernate 的一级缓存结构 一级缓存内部存在一个特殊的区域：快照区 123456789101112@Test// 测试一级缓存的快照区public void demo2() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); Customer customer1 = session.get(Customer.class, 1l); // 发送 SQL 语句，同时放到一级缓存和快照区 customer1.setCust_name("李四"); tx.commit(); session.close();&#125; Hibernate 的事务管理什么是事务事务指的是逻辑上的一组操作，组成这组操作的各个逻辑单元要么全部成功，要么全部失败。 事务的特性 原子性：代表事务不可分割。 一致性：代表事务执行前后，数据完整性保持一致。 隔离性：代表一个事务在执行过程中，不应该受到其他事务的干扰。 持久性：代表事务执行结束后，数据会持久保存到数据库中。 如果不考虑隔离性，引发的安全性问题读问题 脏读： 一个事务读到另一个事务未提交的数据。 不可重复读：一个事务读到另一个事务已提交的 update 更新数据，导致在前一个事务中多次查询结果不一致。 虚读：一个事务读到另一个事务已提交的 insert 添加数据，导致在前一个事务中多次查询结果不一致。 写问题 引发两类丢失更新 读写问题的解决通过设置事务的更新级别控制 Read uncommited：不能解决任何问题。 Read commited：可以解决脏读，但是不可重复读和虚读可能发生。（Oracle 的默认事务隔离级别） Repeatable read：可以解决脏读和不可重复读，但是虚读可能发生。（MySQL 的默认事务隔离级别） Serializable：可以解决所有的读问题，它属于死锁，安全性高，但效率低。 Hibernate 中设置事务隔离级别可以在 hibernate 的核心配置文件中设置 123&lt;!-- 设置事务隔离级别 --&gt;&lt;!-- 4 为 MySql 的默认级别 --&gt;&lt;property name="hibernate.connection.isolation"&gt;4&lt;/property&gt; 线程绑定 Session 将 Session 与当前线程绑定方便事务控制 改写使用 Hibernate 操作数据库的工具类123456789101112131415161718192021222324public class HibernateUtils &#123; // 创建 Configuration 对象 private final static Configuration cfg; // 创建 SessionFactory 对象 private final static SessionFactory sf; // 给两个变量赋值 static &#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; // 对外提供公共的方法获得连接对象 public static Session openSession() &#123; return sf.openSession(); &#125; // 将 Session 与当前线程绑定 public static Session getCurrentSession() &#123; return sf.getCurrentSession(); &#125; &#125; 在 Hibernate 核心配置文件中配置 要使用 getCurrentSession() 方法，需要在 hibernate 核心配置文件中配置后才能使用 12&lt;!-- 配置 session 绑定当前线程 --&gt;&lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt; Hibernate 的其他 APIQueryQuery 代表面向对象的一个 Hibernate 查询操作，通常使用 session.createQuery() 方法接收一个 HQL（Hibernate Query Language）语句，然后进行查询操作。 12345678910111213141516171819202122232425262728293031@Test// Querypublic void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 // 通过 Session 获得 Query 接口，HQL：hibernate query language /* String hql = "from Customer"; Query query = session.createQuery(hql);*/ // 条件查询 /*String hql = "from Customer where cust_name like ?"; Query query = session.createQuery(hql); // 设置条件 query.setParameter(0, "张%"); // 在 hibernate 中 0 代表第一个问号*/ // 分页查询 String hql = "from Customer"; Query query = session.createQuery(hql); // 设置分页 query.setFirstResult(0); // 从第一条数据开始 query.setMaxResults(3); // 每页显示 3 条数据 List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; CriteriaCriteria 是一个完全面向对象，可扩展的条件查询 API，Criteria 查询又称为 QBC（Query By Criteria）查询。 1234567891011121314151617181920212223242526@Test// Criteriapublic void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过 Session 获得 Criteria 接口 Criteria criteria = session.createCriteria(Customer.class); // 简单查询/查询所有 // List&lt;Customer&gt; list = criteria.list(); // 条件查询 /*criteria.add(Restrictions.like("cust_name", "张", MatchMode.START)); // 匹配名字开头是张的数据 List&lt;Customer&gt; list = criteria.list();*/ // 分页查询 criteria.setFirstResult(3); criteria.setMaxResults(3); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit();&#125; SQLQuerySQLQuery 这个接口用于接收一个 sql 语句进行查询。 123456789101112131415161718192021222324252627282930@Test// SQLQuerypublic void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 /*String sql = "select * from cst_customer"; SQLQuery query = session.createSQLQuery(sql);*/ // 条件查询 /*String sql = "select * from cst_customer where cust_name=?"; SQLQuery query = session.createSQLQuery(sql); // 设置条件 query.setParameter(0, "哈哈");*/ // 分页查询 String sql = "select * from cst_customer limit ?, ?"; SQLQuery query = session.createSQLQuery(sql); // 设置分页 query.setParameter(0, 3); query.setParameter(1, 3); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit();&#125; 注意将 Session 绑定在线程上后，当线程执行完毕之后，Session 对象也会自动关闭，不需要手动 session.close() 关闭，否则会报错。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate (一)]]></title>
    <url>%2Fhibernate01%2F</url>
    <content type="text"><![CDATA[Hibernate 框架概述 什么是框架 框架是软件的半成品，已经完成了部分功能，可以提交开发效率。 什么是 Hibernate 简单地说，Hibernate 就是持久层（dao 层） 的 ORM 框架。 什么是 ORM ORM：全称 Object Relational Mapping，意思即对象关系映射，指的是将一个 Java 中的实体类与关系型数据库中的表建立一种映射关系，从而操作对象就可以操作数据库中的表。 Hibernate 的入门 下载 Hibernate 开发环境并解压到本地 下载地址 创建一个项目，引入相应的 jar 包 数据库驱动包 Hibernate 开发的必须 jar 包 Hibernate 的日志记录包 在数据库中创建表 建表 SQL 语句 12345678910CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)', `cust_name` varchar(32) NOT NULL COMMENT '客户名称(公司名称)', `cust_source` varchar(32) DEFAULT NULL COMMENT '客户信息来源', `cust_industry` varchar(32) DEFAULT NULL COMMENT '客户所属行业', `cust_level` varchar(32) DEFAULT NULL COMMENT '客户级别', `cust_phone` varchar(64) DEFAULT NULL COMMENT '固定电话', `cust_mobile` varchar(16) DEFAULT NULL COMMENT '移动电话', PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 创建实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Customer &#123; private Long cust_id; private String cust_name; private String cust_source; private String cust_industry; private String cust_level; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125; @Override public String toString() &#123; return "Customer [cust_id=" + cust_id + ", cust_name=" + cust_name + ", cust_source=" + cust_source + ", cust_industry=" + cust_industry + ", cust_level=" + cust_level + ", cust_phone=" + cust_phone + ", cust_mobile=" + cust_mobile + "]"; &#125;&#125; 创建映射 映射通过 XML 的配置文件完成，配置文件可以任意命名，但通常使用统一命名规范（类名.hbm.xml）[hbm : hibernate mapping] 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;!-- 建立类与表的映射 --&gt; &lt;class name=&quot;com.test.hibernate.demo1.Customer&quot; table=&quot;cst_customer&quot;&gt; &lt;!-- 建立类中的属性与表中的主键对应 --&gt; &lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot; &gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 建立类中的普通的属性和表的字段的对应 --&gt; &lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot; length=&quot;32&quot; /&gt; &lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot; length=&quot;32&quot;/&gt; &lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&gt; &lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&gt; &lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&gt; &lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 创建一个 Hibernate 核心配置文件 Hibernate 核心配置文件的名称：hibernate.cfg.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 1. 连接数据库的基本参数 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;1&lt;/property&gt; &lt;!-- 配置Hibernate的方言 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 2. 可选配置 --&gt; &lt;!-- 打印SQL --&gt; &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 格式化SQL --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 自动创建表 --&gt; &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!-- 3. 导入映射文件 --&gt; &lt;mapping resource=&quot;com/test/hibernate/demo1/Customer.hbm.xml&quot; /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 编写测试代码 保存客户 java 代码 123456789101112131415161718192021222324252627282930313233343536373839/** * Hibernate 的入门案例 * @author Tong * */import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;public class HibernateDemo1 &#123; @Test // 保存客户的案例 public void demo1() &#123; // 1.加载 Hibernate 核心配置文件 Configuration configuration = new Configuration().configure(); // 手动加载映射 //configuration.addResource("com/test/hibernate/demo1/Customer.hbm.xml"); // 2.创建一个 SessionFactory 对象，类似于 JDBC 的连接池 SessionFactory SessionFactory = configuration.buildSessionFactory(); // 3.通过 SessionFactory 对象获得一个 Session 对象，相当于 JDBC 中的 Connection Session session = SessionFactory.openSession(); // 4.手动开启事务 Transaction transaction = session.beginTransaction(); // 5.编写代码 Customer customer = new Customer(); customer.setCust_name("赵六"); session.save(customer); // 6.提交事务 transaction.commit(); // 7.释放资源 session.close(); &#125; &#125; 数据库表 Hibernate 的常见配置XML 提示配置 Hibernate 映射文件的配置 class 标签的配置 class 标签用来建立类与表的映射关系 常用属性： ​ name：类的全路径 ​ table：表名（类名与表名一致时，table 可以省略） id 标签的配置 id 标签用来建立类中属性与表中主键的对应关系 常用属性： ​ name：类中的属性名 ​ column：表中的字段名（类中的属性名与表中的字段名一致时，column 属性可以省略） ​ length：长度 ​ type：类型 property 标签的配置 property 标签用来建立类中的普通属性与表中字段的对应关系 常用属性： ​ name：类中的属性名 ​ column：表中的字段名 ​ length：长度 ​ type：类型 ​ not-null：设置非空 ​ unique：设置唯一 Hibernate 的核心配置 可以分为三部分 必须的配置 连接数据库的基本参数 驱动类、url 路径、用户名、密码 方言 可选的配置 显示 SQL：hibernate.show_sql 格式化 SQL：hibernate.format_sql 自动建表：hibernate.hbm2ddl.auto 取值 none：不使用 hibernate 的自动建表 ceate：如果数据库中有表，删除原有表，重新创建，如果没有表，则新建表 create-drop：如果数据库中有表，删除原有表新建表，执行操作后再删除表。如果没有表，则新建表，使用完后再删除该表 update：如果数据库中有表，使用原有表（update 会该表表结构），如果没有表，则创建新表 validate：如果数据库中没有表，不会创建表，如果有表，则会校验映射和表结构 映射文件的引入 引入映射文件的位置 1&lt;mapping resource=&quot;com/test/hibernate/demo1/Customer.hbm.xml&quot; /&gt; Hibernate 的核心 APIConfiguration Hibernate 的配置对象 作用 加载核心配置文件 1Configuration configuration = new Configuration().configure(); 可手动加载映射文件 1configuration.addResource("com/test/hibernate/demo1/Customer.hbm.xml"); SessionFactory Session 工厂，SessionFactory 内部维护了 Hibernate 的连接池和 Hibernate 的二级缓存，是线程安全的对象，其次一个项目创建一个对象即可。 配置连接池 1234567891011&lt;!-- 配置C3P0连接池 --&gt;&lt;property name=&quot;connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt;&lt;!--在连接池中可用的数据库连接的最少数目 --&gt;&lt;property name=&quot;c3p0.min_size&quot;&gt;5&lt;/property&gt;&lt;!--在连接池中所有数据库连接的最大数目 --&gt;&lt;property name=&quot;c3p0.max_size&quot;&gt;20&lt;/property&gt;&lt;!--设定数据库连接的过期时间,以秒为单位,如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt;&lt;property name=&quot;c3p0.timeout&quot;&gt;120&lt;/property&gt;&lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt;&lt;property name=&quot;c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; 抽取 Hibernate 工具类，方便使用 123456789101112131415161718192021222324/** * Hibernate 的工具类 * @author Tong * */public class HibernateUtils &#123; // 创建 Configuration 对象 private final static Configuration cfg; // 创建 SessionFactory 对象 private final static SessionFactory sf; // 给两个变量赋值 static &#123; cfg = new Configuration().configure(); sf = cfg.buildSessionFactory(); &#125; // 对外提供公共的方法获得连接对象 public static Session openSession() &#123; return sf.openSession(); &#125; &#125; Session Session 代表的是 Hibernate 与数据库的连接对象，是与数据库交互的桥梁，不同于 HttpSession，它是线程不安全的，所以一般在局部使用。 Session 中的 API 保存方法 session.save(Object)返回值是一个Serializable id 12345678910111213141516@Test// 保存客户public void demo1() &#123; // 获得 Session 连接对象 Session session = HibernateUtils.openSession(); // 手动开启事务 Transaction transaction = session.beginTransaction(); // 编写代码 Customer customer = new Customer(); customer.setCust_name("张三"); session.save(customer); // 提交事务 transaction.commit(); // 释放资源 session.close();&#125; 查询方法 T get(Class c, Serializable id) T load(Class c, Serialzable id) get 方法和 load 方法的区别？ get 方法 get 方法是立即加载，当执行到 get() 方法这行代码时，会立即发送 SQL 语句去查询 查询之后是真实对象本身 当查询一个不存在的对象时，返回的结果是 null load 方法 load 方法是延时加载（懒加载），当执行到 load() 方法这行代码时，不会发送 SQL 语句去查询，直到调用该对象时才会发送 SQL 语句去查询 查询之后是通过第三方 javassist 技术处理的代理对象 当查询一个不存在的对象时，会抛出 ObjectNotFoundException 异常 1234567891011121314151617@Test// 查询客户public void demo2() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 使用 get 方法查询 Customer customer = session.get(Customer.class, 1L); System.out.println(customer); // 使用 load 方法查询 /*Customer customer = session.load(Customer.class, 2l); System.out.println(customer);*/ tx.commit(); session.close();&#125; 修改方法 void update(Object obj) 1234567891011121314151617181920@Test// 修改操作public void demo3() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 直接创建对象修改 /*Customer customer = new Customer(); customer.setCust_id(1l); customer.setCust_name("王五");; session.update(customer);*/ // 先查询，再修改(推荐) Customer customer = session.get(Customer.class, 1l); customer.setCust_name("赵六"); session.update(customer); tx.commit(); session.close();&#125; 删除方法 void delete(Object obj) 123456789101112131415161718@Test// 删除操作public void delete() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 创建对象直接删除 /*Customer customer = new Customer(); customer.setCust_id(2l); session.delete(customer);*/ // 先查询，再删除(推荐) -- 多表关系时可以实现级联删除 Customer customer = session.get(Customer.class, 3l); session.delete(customer); tx.commit(); session.close();&#125; 保存或更新 void saveOrUpdate(Object obj) 12345678910111213141516171819@Test// 保存或更新public void demo5() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 表中没有此数据，保存 /*Customer customer = new Customer(); customer.setCust_name("赵二"); session.saveOrUpdate(customer);*/ // 表中有此数据，更新 Customer customer = new Customer(); customer.setCust_id(2l); customer.setCust_name("天一"); session.saveOrUpdate(customer); tx.commit(); session.close();&#125; 查询所有 通过 HQL createQuery 和 SQL createSQLQuery 查询 1234567891011121314151617181920212223@Test// 查询所有public void demo6() &#123; Session session = HibernateUtils.openSession(); Transaction tx = session.beginTransaction(); // 接收 HQL，hibernate query language /*Query query = session.createQuery("from Customer"); List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer.toString()); &#125;*/ // 接收 SQL SQLQuery query = session.createSQLQuery("select * from cst_customer"); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; // 对象数组以字符串形式打印输出 System.out.println(Arrays.toString(objects)); &#125; tx.commit(); session.close();&#125; Transaction 事务对象 常用 API commit():提交事务 rollback():回滚事务 学习目标通过以上知识的学习能够独立搭建 Hibernate 的开发环境完成 CRUD 操作即可。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[This is my first blog.Hello, everyone! This is my first blog! java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Hibernate 的其他 API * @author Tong * */public class HibernateDemo5 &#123; @Test // Query public void demo1() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 // 通过 Session 获得 Query 接口，HQL：hibernate query language /* String hql = "from Customer"; Query query = session.createQuery(hql);*/ // 条件查询 /*String hql = "from Customer where cust_name like ?"; Query query = session.createQuery(hql); // 设置条件 query.setParameter(0, "张%"); // 在 hibernate 中 0 代表第一个问号*/ // 分页查询 String hql = "from Customer"; Query query = session.createQuery(hql); // 设置分页 query.setFirstResult(0); // 从第一条数据开始 query.setMaxResults(3); // 每页显示 3 条数据 List&lt;Customer&gt; list = query.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit(); &#125; @Test // Criteria public void demo2() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 通过 Session 获得 Criteria 接口 Criteria criteria = session.createCriteria(Customer.class); // 简单查询/查询所有 // List&lt;Customer&gt; list = criteria.list(); // 条件查询 /*criteria.add(Restrictions.like("cust_name", "张", MatchMode.START)); // 匹配名字开头是张的数据 List&lt;Customer&gt; list = criteria.list();*/ // 分页查询 criteria.setFirstResult(3); criteria.setMaxResults(3); List&lt;Customer&gt; list = criteria.list(); for (Customer customer : list) &#123; System.out.println(customer); &#125; tx.commit(); &#125; @Test // SQLQuery public void demo3() &#123; Session session = HibernateUtils.getCurrentSession(); Transaction tx = session.beginTransaction(); // 简单查询/查询所有 /*String sql = "select * from cst_customer"; SQLQuery query = session.createSQLQuery(sql);*/ // 条件查询 /*String sql = "select * from cst_customer where cust_name=?"; SQLQuery query = session.createSQLQuery(sql); // 设置条件 query.setParameter(0, "哈哈");*/ // 分页查询 String sql = "select * from cst_customer limit ?, ?"; SQLQuery query = session.createSQLQuery(sql); // 设置分页 query.setParameter(0, 3); query.setParameter(1, 3); List&lt;Object[]&gt; list = query.list(); for (Object[] objects : list) &#123; System.out.println(Arrays.toString(objects)); &#125; tx.commit(); &#125; &#125;]]></content>
  </entry>
</search>
